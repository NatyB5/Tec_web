
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model CARTELA
 * 
 */
export type CARTELA = $Result.DefaultSelection<Prisma.$CARTELAPayload>
/**
 * Model JOGO
 * 
 */
export type JOGO = $Result.DefaultSelection<Prisma.$JOGOPayload>
/**
 * Model NUMEROS_CARTELA
 * 
 */
export type NUMEROS_CARTELA = $Result.DefaultSelection<Prisma.$NUMEROS_CARTELAPayload>
/**
 * Model NUMEROS_SORTEADOS
 * 
 */
export type NUMEROS_SORTEADOS = $Result.DefaultSelection<Prisma.$NUMEROS_SORTEADOSPayload>
/**
 * Model PREMIOS
 * 
 */
export type PREMIOS = $Result.DefaultSelection<Prisma.$PREMIOSPayload>
/**
 * Model SALA
 * 
 */
export type SALA = $Result.DefaultSelection<Prisma.$SALAPayload>
/**
 * Model USUARIO
 * 
 */
export type USUARIO = $Result.DefaultSelection<Prisma.$USUARIOPayload>

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more CARTELAS
 * const cARTELAS = await prisma.cARTELA.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more CARTELAS
   * const cARTELAS = await prisma.cARTELA.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.cARTELA`: Exposes CRUD operations for the **CARTELA** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CARTELAS
    * const cARTELAS = await prisma.cARTELA.findMany()
    * ```
    */
  get cARTELA(): Prisma.CARTELADelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.jOGO`: Exposes CRUD operations for the **JOGO** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more JOGOS
    * const jOGOS = await prisma.jOGO.findMany()
    * ```
    */
  get jOGO(): Prisma.JOGODelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.nUMEROS_CARTELA`: Exposes CRUD operations for the **NUMEROS_CARTELA** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NUMEROS_CARTELAS
    * const nUMEROS_CARTELAS = await prisma.nUMEROS_CARTELA.findMany()
    * ```
    */
  get nUMEROS_CARTELA(): Prisma.NUMEROS_CARTELADelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.nUMEROS_SORTEADOS`: Exposes CRUD operations for the **NUMEROS_SORTEADOS** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NUMEROS_SORTEADOS
    * const nUMEROS_SORTEADOS = await prisma.nUMEROS_SORTEADOS.findMany()
    * ```
    */
  get nUMEROS_SORTEADOS(): Prisma.NUMEROS_SORTEADOSDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.pREMIOS`: Exposes CRUD operations for the **PREMIOS** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PREMIOS
    * const pREMIOS = await prisma.pREMIOS.findMany()
    * ```
    */
  get pREMIOS(): Prisma.PREMIOSDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sALA`: Exposes CRUD operations for the **SALA** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SALAS
    * const sALAS = await prisma.sALA.findMany()
    * ```
    */
  get sALA(): Prisma.SALADelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.uSUARIO`: Exposes CRUD operations for the **USUARIO** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more USUARIOS
    * const uSUARIOS = await prisma.uSUARIO.findMany()
    * ```
    */
  get uSUARIO(): Prisma.USUARIODelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.17.1
   * Query Engine version: 272a37d34178c2894197e17273bf937f25acdeac
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    CARTELA: 'CARTELA',
    JOGO: 'JOGO',
    NUMEROS_CARTELA: 'NUMEROS_CARTELA',
    NUMEROS_SORTEADOS: 'NUMEROS_SORTEADOS',
    PREMIOS: 'PREMIOS',
    SALA: 'SALA',
    USUARIO: 'USUARIO'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "cARTELA" | "jOGO" | "nUMEROS_CARTELA" | "nUMEROS_SORTEADOS" | "pREMIOS" | "sALA" | "uSUARIO"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      CARTELA: {
        payload: Prisma.$CARTELAPayload<ExtArgs>
        fields: Prisma.CARTELAFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CARTELAFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CARTELAPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CARTELAFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CARTELAPayload>
          }
          findFirst: {
            args: Prisma.CARTELAFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CARTELAPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CARTELAFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CARTELAPayload>
          }
          findMany: {
            args: Prisma.CARTELAFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CARTELAPayload>[]
          }
          create: {
            args: Prisma.CARTELACreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CARTELAPayload>
          }
          createMany: {
            args: Prisma.CARTELACreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CARTELADeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CARTELAPayload>
          }
          update: {
            args: Prisma.CARTELAUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CARTELAPayload>
          }
          deleteMany: {
            args: Prisma.CARTELADeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CARTELAUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CARTELAUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CARTELAPayload>
          }
          aggregate: {
            args: Prisma.CARTELAAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCARTELA>
          }
          groupBy: {
            args: Prisma.CARTELAGroupByArgs<ExtArgs>
            result: $Utils.Optional<CARTELAGroupByOutputType>[]
          }
          count: {
            args: Prisma.CARTELACountArgs<ExtArgs>
            result: $Utils.Optional<CARTELACountAggregateOutputType> | number
          }
        }
      }
      JOGO: {
        payload: Prisma.$JOGOPayload<ExtArgs>
        fields: Prisma.JOGOFieldRefs
        operations: {
          findUnique: {
            args: Prisma.JOGOFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JOGOPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.JOGOFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JOGOPayload>
          }
          findFirst: {
            args: Prisma.JOGOFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JOGOPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.JOGOFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JOGOPayload>
          }
          findMany: {
            args: Prisma.JOGOFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JOGOPayload>[]
          }
          create: {
            args: Prisma.JOGOCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JOGOPayload>
          }
          createMany: {
            args: Prisma.JOGOCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.JOGODeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JOGOPayload>
          }
          update: {
            args: Prisma.JOGOUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JOGOPayload>
          }
          deleteMany: {
            args: Prisma.JOGODeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.JOGOUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.JOGOUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JOGOPayload>
          }
          aggregate: {
            args: Prisma.JOGOAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateJOGO>
          }
          groupBy: {
            args: Prisma.JOGOGroupByArgs<ExtArgs>
            result: $Utils.Optional<JOGOGroupByOutputType>[]
          }
          count: {
            args: Prisma.JOGOCountArgs<ExtArgs>
            result: $Utils.Optional<JOGOCountAggregateOutputType> | number
          }
        }
      }
      NUMEROS_CARTELA: {
        payload: Prisma.$NUMEROS_CARTELAPayload<ExtArgs>
        fields: Prisma.NUMEROS_CARTELAFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NUMEROS_CARTELAFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NUMEROS_CARTELAPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NUMEROS_CARTELAFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NUMEROS_CARTELAPayload>
          }
          findFirst: {
            args: Prisma.NUMEROS_CARTELAFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NUMEROS_CARTELAPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NUMEROS_CARTELAFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NUMEROS_CARTELAPayload>
          }
          findMany: {
            args: Prisma.NUMEROS_CARTELAFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NUMEROS_CARTELAPayload>[]
          }
          create: {
            args: Prisma.NUMEROS_CARTELACreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NUMEROS_CARTELAPayload>
          }
          createMany: {
            args: Prisma.NUMEROS_CARTELACreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.NUMEROS_CARTELADeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NUMEROS_CARTELAPayload>
          }
          update: {
            args: Prisma.NUMEROS_CARTELAUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NUMEROS_CARTELAPayload>
          }
          deleteMany: {
            args: Prisma.NUMEROS_CARTELADeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NUMEROS_CARTELAUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NUMEROS_CARTELAUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NUMEROS_CARTELAPayload>
          }
          aggregate: {
            args: Prisma.NUMEROS_CARTELAAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNUMEROS_CARTELA>
          }
          groupBy: {
            args: Prisma.NUMEROS_CARTELAGroupByArgs<ExtArgs>
            result: $Utils.Optional<NUMEROS_CARTELAGroupByOutputType>[]
          }
          count: {
            args: Prisma.NUMEROS_CARTELACountArgs<ExtArgs>
            result: $Utils.Optional<NUMEROS_CARTELACountAggregateOutputType> | number
          }
        }
      }
      NUMEROS_SORTEADOS: {
        payload: Prisma.$NUMEROS_SORTEADOSPayload<ExtArgs>
        fields: Prisma.NUMEROS_SORTEADOSFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NUMEROS_SORTEADOSFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NUMEROS_SORTEADOSPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NUMEROS_SORTEADOSFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NUMEROS_SORTEADOSPayload>
          }
          findFirst: {
            args: Prisma.NUMEROS_SORTEADOSFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NUMEROS_SORTEADOSPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NUMEROS_SORTEADOSFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NUMEROS_SORTEADOSPayload>
          }
          findMany: {
            args: Prisma.NUMEROS_SORTEADOSFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NUMEROS_SORTEADOSPayload>[]
          }
          create: {
            args: Prisma.NUMEROS_SORTEADOSCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NUMEROS_SORTEADOSPayload>
          }
          createMany: {
            args: Prisma.NUMEROS_SORTEADOSCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.NUMEROS_SORTEADOSDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NUMEROS_SORTEADOSPayload>
          }
          update: {
            args: Prisma.NUMEROS_SORTEADOSUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NUMEROS_SORTEADOSPayload>
          }
          deleteMany: {
            args: Prisma.NUMEROS_SORTEADOSDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NUMEROS_SORTEADOSUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NUMEROS_SORTEADOSUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NUMEROS_SORTEADOSPayload>
          }
          aggregate: {
            args: Prisma.NUMEROS_SORTEADOSAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNUMEROS_SORTEADOS>
          }
          groupBy: {
            args: Prisma.NUMEROS_SORTEADOSGroupByArgs<ExtArgs>
            result: $Utils.Optional<NUMEROS_SORTEADOSGroupByOutputType>[]
          }
          count: {
            args: Prisma.NUMEROS_SORTEADOSCountArgs<ExtArgs>
            result: $Utils.Optional<NUMEROS_SORTEADOSCountAggregateOutputType> | number
          }
        }
      }
      PREMIOS: {
        payload: Prisma.$PREMIOSPayload<ExtArgs>
        fields: Prisma.PREMIOSFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PREMIOSFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PREMIOSPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PREMIOSFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PREMIOSPayload>
          }
          findFirst: {
            args: Prisma.PREMIOSFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PREMIOSPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PREMIOSFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PREMIOSPayload>
          }
          findMany: {
            args: Prisma.PREMIOSFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PREMIOSPayload>[]
          }
          create: {
            args: Prisma.PREMIOSCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PREMIOSPayload>
          }
          createMany: {
            args: Prisma.PREMIOSCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PREMIOSDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PREMIOSPayload>
          }
          update: {
            args: Prisma.PREMIOSUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PREMIOSPayload>
          }
          deleteMany: {
            args: Prisma.PREMIOSDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PREMIOSUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PREMIOSUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PREMIOSPayload>
          }
          aggregate: {
            args: Prisma.PREMIOSAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePREMIOS>
          }
          groupBy: {
            args: Prisma.PREMIOSGroupByArgs<ExtArgs>
            result: $Utils.Optional<PREMIOSGroupByOutputType>[]
          }
          count: {
            args: Prisma.PREMIOSCountArgs<ExtArgs>
            result: $Utils.Optional<PREMIOSCountAggregateOutputType> | number
          }
        }
      }
      SALA: {
        payload: Prisma.$SALAPayload<ExtArgs>
        fields: Prisma.SALAFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SALAFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SALAPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SALAFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SALAPayload>
          }
          findFirst: {
            args: Prisma.SALAFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SALAPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SALAFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SALAPayload>
          }
          findMany: {
            args: Prisma.SALAFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SALAPayload>[]
          }
          create: {
            args: Prisma.SALACreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SALAPayload>
          }
          createMany: {
            args: Prisma.SALACreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SALADeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SALAPayload>
          }
          update: {
            args: Prisma.SALAUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SALAPayload>
          }
          deleteMany: {
            args: Prisma.SALADeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SALAUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SALAUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SALAPayload>
          }
          aggregate: {
            args: Prisma.SALAAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSALA>
          }
          groupBy: {
            args: Prisma.SALAGroupByArgs<ExtArgs>
            result: $Utils.Optional<SALAGroupByOutputType>[]
          }
          count: {
            args: Prisma.SALACountArgs<ExtArgs>
            result: $Utils.Optional<SALACountAggregateOutputType> | number
          }
        }
      }
      USUARIO: {
        payload: Prisma.$USUARIOPayload<ExtArgs>
        fields: Prisma.USUARIOFieldRefs
        operations: {
          findUnique: {
            args: Prisma.USUARIOFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$USUARIOPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.USUARIOFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$USUARIOPayload>
          }
          findFirst: {
            args: Prisma.USUARIOFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$USUARIOPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.USUARIOFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$USUARIOPayload>
          }
          findMany: {
            args: Prisma.USUARIOFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$USUARIOPayload>[]
          }
          create: {
            args: Prisma.USUARIOCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$USUARIOPayload>
          }
          createMany: {
            args: Prisma.USUARIOCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.USUARIODeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$USUARIOPayload>
          }
          update: {
            args: Prisma.USUARIOUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$USUARIOPayload>
          }
          deleteMany: {
            args: Prisma.USUARIODeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.USUARIOUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.USUARIOUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$USUARIOPayload>
          }
          aggregate: {
            args: Prisma.USUARIOAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUSUARIO>
          }
          groupBy: {
            args: Prisma.USUARIOGroupByArgs<ExtArgs>
            result: $Utils.Optional<USUARIOGroupByOutputType>[]
          }
          count: {
            args: Prisma.USUARIOCountArgs<ExtArgs>
            result: $Utils.Optional<USUARIOCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    cARTELA?: CARTELAOmit
    jOGO?: JOGOOmit
    nUMEROS_CARTELA?: NUMEROS_CARTELAOmit
    nUMEROS_SORTEADOS?: NUMEROS_SORTEADOSOmit
    pREMIOS?: PREMIOSOmit
    sALA?: SALAOmit
    uSUARIO?: USUARIOOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type CARTELACountOutputType
   */

  export type CARTELACountOutputType = {
    NUMEROS_CARTELA: number
  }

  export type CARTELACountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    NUMEROS_CARTELA?: boolean | CARTELACountOutputTypeCountNUMEROS_CARTELAArgs
  }

  // Custom InputTypes
  /**
   * CARTELACountOutputType without action
   */
  export type CARTELACountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CARTELACountOutputType
     */
    select?: CARTELACountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CARTELACountOutputType without action
   */
  export type CARTELACountOutputTypeCountNUMEROS_CARTELAArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NUMEROS_CARTELAWhereInput
  }


  /**
   * Count Type JOGOCountOutputType
   */

  export type JOGOCountOutputType = {
    CARTELA: number
    NUMEROS_SORTEADOS: number
    PREMIOS: number
  }

  export type JOGOCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    CARTELA?: boolean | JOGOCountOutputTypeCountCARTELAArgs
    NUMEROS_SORTEADOS?: boolean | JOGOCountOutputTypeCountNUMEROS_SORTEADOSArgs
    PREMIOS?: boolean | JOGOCountOutputTypeCountPREMIOSArgs
  }

  // Custom InputTypes
  /**
   * JOGOCountOutputType without action
   */
  export type JOGOCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JOGOCountOutputType
     */
    select?: JOGOCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * JOGOCountOutputType without action
   */
  export type JOGOCountOutputTypeCountCARTELAArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CARTELAWhereInput
  }

  /**
   * JOGOCountOutputType without action
   */
  export type JOGOCountOutputTypeCountNUMEROS_SORTEADOSArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NUMEROS_SORTEADOSWhereInput
  }

  /**
   * JOGOCountOutputType without action
   */
  export type JOGOCountOutputTypeCountPREMIOSArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PREMIOSWhereInput
  }


  /**
   * Count Type SALACountOutputType
   */

  export type SALACountOutputType = {
    JOGO: number
  }

  export type SALACountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    JOGO?: boolean | SALACountOutputTypeCountJOGOArgs
  }

  // Custom InputTypes
  /**
   * SALACountOutputType without action
   */
  export type SALACountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SALACountOutputType
     */
    select?: SALACountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SALACountOutputType without action
   */
  export type SALACountOutputTypeCountJOGOArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JOGOWhereInput
  }


  /**
   * Count Type USUARIOCountOutputType
   */

  export type USUARIOCountOutputType = {
    CARTELA: number
    JOGO: number
    PREMIOS: number
  }

  export type USUARIOCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    CARTELA?: boolean | USUARIOCountOutputTypeCountCARTELAArgs
    JOGO?: boolean | USUARIOCountOutputTypeCountJOGOArgs
    PREMIOS?: boolean | USUARIOCountOutputTypeCountPREMIOSArgs
  }

  // Custom InputTypes
  /**
   * USUARIOCountOutputType without action
   */
  export type USUARIOCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the USUARIOCountOutputType
     */
    select?: USUARIOCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * USUARIOCountOutputType without action
   */
  export type USUARIOCountOutputTypeCountCARTELAArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CARTELAWhereInput
  }

  /**
   * USUARIOCountOutputType without action
   */
  export type USUARIOCountOutputTypeCountJOGOArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JOGOWhereInput
  }

  /**
   * USUARIOCountOutputType without action
   */
  export type USUARIOCountOutputTypeCountPREMIOSArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PREMIOSWhereInput
  }


  /**
   * Models
   */

  /**
   * Model CARTELA
   */

  export type AggregateCARTELA = {
    _count: CARTELACountAggregateOutputType | null
    _avg: CARTELAAvgAggregateOutputType | null
    _sum: CARTELASumAggregateOutputType | null
    _min: CARTELAMinAggregateOutputType | null
    _max: CARTELAMaxAggregateOutputType | null
  }

  export type CARTELAAvgAggregateOutputType = {
    id_cartela: number | null
    id_usuario: number | null
    id_jogo: number | null
  }

  export type CARTELASumAggregateOutputType = {
    id_cartela: number | null
    id_usuario: number | null
    id_jogo: number | null
  }

  export type CARTELAMinAggregateOutputType = {
    id_cartela: number | null
    id_usuario: number | null
    id_jogo: number | null
  }

  export type CARTELAMaxAggregateOutputType = {
    id_cartela: number | null
    id_usuario: number | null
    id_jogo: number | null
  }

  export type CARTELACountAggregateOutputType = {
    id_cartela: number
    id_usuario: number
    id_jogo: number
    _all: number
  }


  export type CARTELAAvgAggregateInputType = {
    id_cartela?: true
    id_usuario?: true
    id_jogo?: true
  }

  export type CARTELASumAggregateInputType = {
    id_cartela?: true
    id_usuario?: true
    id_jogo?: true
  }

  export type CARTELAMinAggregateInputType = {
    id_cartela?: true
    id_usuario?: true
    id_jogo?: true
  }

  export type CARTELAMaxAggregateInputType = {
    id_cartela?: true
    id_usuario?: true
    id_jogo?: true
  }

  export type CARTELACountAggregateInputType = {
    id_cartela?: true
    id_usuario?: true
    id_jogo?: true
    _all?: true
  }

  export type CARTELAAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CARTELA to aggregate.
     */
    where?: CARTELAWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CARTELAS to fetch.
     */
    orderBy?: CARTELAOrderByWithRelationInput | CARTELAOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CARTELAWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CARTELAS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CARTELAS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CARTELAS
    **/
    _count?: true | CARTELACountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CARTELAAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CARTELASumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CARTELAMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CARTELAMaxAggregateInputType
  }

  export type GetCARTELAAggregateType<T extends CARTELAAggregateArgs> = {
        [P in keyof T & keyof AggregateCARTELA]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCARTELA[P]>
      : GetScalarType<T[P], AggregateCARTELA[P]>
  }




  export type CARTELAGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CARTELAWhereInput
    orderBy?: CARTELAOrderByWithAggregationInput | CARTELAOrderByWithAggregationInput[]
    by: CARTELAScalarFieldEnum[] | CARTELAScalarFieldEnum
    having?: CARTELAScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CARTELACountAggregateInputType | true
    _avg?: CARTELAAvgAggregateInputType
    _sum?: CARTELASumAggregateInputType
    _min?: CARTELAMinAggregateInputType
    _max?: CARTELAMaxAggregateInputType
  }

  export type CARTELAGroupByOutputType = {
    id_cartela: number
    id_usuario: number
    id_jogo: number
    _count: CARTELACountAggregateOutputType | null
    _avg: CARTELAAvgAggregateOutputType | null
    _sum: CARTELASumAggregateOutputType | null
    _min: CARTELAMinAggregateOutputType | null
    _max: CARTELAMaxAggregateOutputType | null
  }

  type GetCARTELAGroupByPayload<T extends CARTELAGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CARTELAGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CARTELAGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CARTELAGroupByOutputType[P]>
            : GetScalarType<T[P], CARTELAGroupByOutputType[P]>
        }
      >
    >


  export type CARTELASelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_cartela?: boolean
    id_usuario?: boolean
    id_jogo?: boolean
    JOGO?: boolean | JOGODefaultArgs<ExtArgs>
    USUARIO?: boolean | USUARIODefaultArgs<ExtArgs>
    NUMEROS_CARTELA?: boolean | CARTELA$NUMEROS_CARTELAArgs<ExtArgs>
    _count?: boolean | CARTELACountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cARTELA"]>



  export type CARTELASelectScalar = {
    id_cartela?: boolean
    id_usuario?: boolean
    id_jogo?: boolean
  }

  export type CARTELAOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id_cartela" | "id_usuario" | "id_jogo", ExtArgs["result"]["cARTELA"]>
  export type CARTELAInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    JOGO?: boolean | JOGODefaultArgs<ExtArgs>
    USUARIO?: boolean | USUARIODefaultArgs<ExtArgs>
    NUMEROS_CARTELA?: boolean | CARTELA$NUMEROS_CARTELAArgs<ExtArgs>
    _count?: boolean | CARTELACountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $CARTELAPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CARTELA"
    objects: {
      JOGO: Prisma.$JOGOPayload<ExtArgs>
      USUARIO: Prisma.$USUARIOPayload<ExtArgs>
      NUMEROS_CARTELA: Prisma.$NUMEROS_CARTELAPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id_cartela: number
      id_usuario: number
      id_jogo: number
    }, ExtArgs["result"]["cARTELA"]>
    composites: {}
  }

  type CARTELAGetPayload<S extends boolean | null | undefined | CARTELADefaultArgs> = $Result.GetResult<Prisma.$CARTELAPayload, S>

  type CARTELACountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CARTELAFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CARTELACountAggregateInputType | true
    }

  export interface CARTELADelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CARTELA'], meta: { name: 'CARTELA' } }
    /**
     * Find zero or one CARTELA that matches the filter.
     * @param {CARTELAFindUniqueArgs} args - Arguments to find a CARTELA
     * @example
     * // Get one CARTELA
     * const cARTELA = await prisma.cARTELA.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CARTELAFindUniqueArgs>(args: SelectSubset<T, CARTELAFindUniqueArgs<ExtArgs>>): Prisma__CARTELAClient<$Result.GetResult<Prisma.$CARTELAPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CARTELA that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CARTELAFindUniqueOrThrowArgs} args - Arguments to find a CARTELA
     * @example
     * // Get one CARTELA
     * const cARTELA = await prisma.cARTELA.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CARTELAFindUniqueOrThrowArgs>(args: SelectSubset<T, CARTELAFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CARTELAClient<$Result.GetResult<Prisma.$CARTELAPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CARTELA that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CARTELAFindFirstArgs} args - Arguments to find a CARTELA
     * @example
     * // Get one CARTELA
     * const cARTELA = await prisma.cARTELA.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CARTELAFindFirstArgs>(args?: SelectSubset<T, CARTELAFindFirstArgs<ExtArgs>>): Prisma__CARTELAClient<$Result.GetResult<Prisma.$CARTELAPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CARTELA that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CARTELAFindFirstOrThrowArgs} args - Arguments to find a CARTELA
     * @example
     * // Get one CARTELA
     * const cARTELA = await prisma.cARTELA.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CARTELAFindFirstOrThrowArgs>(args?: SelectSubset<T, CARTELAFindFirstOrThrowArgs<ExtArgs>>): Prisma__CARTELAClient<$Result.GetResult<Prisma.$CARTELAPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CARTELAS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CARTELAFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CARTELAS
     * const cARTELAS = await prisma.cARTELA.findMany()
     * 
     * // Get first 10 CARTELAS
     * const cARTELAS = await prisma.cARTELA.findMany({ take: 10 })
     * 
     * // Only select the `id_cartela`
     * const cARTELAWithId_cartelaOnly = await prisma.cARTELA.findMany({ select: { id_cartela: true } })
     * 
     */
    findMany<T extends CARTELAFindManyArgs>(args?: SelectSubset<T, CARTELAFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CARTELAPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CARTELA.
     * @param {CARTELACreateArgs} args - Arguments to create a CARTELA.
     * @example
     * // Create one CARTELA
     * const CARTELA = await prisma.cARTELA.create({
     *   data: {
     *     // ... data to create a CARTELA
     *   }
     * })
     * 
     */
    create<T extends CARTELACreateArgs>(args: SelectSubset<T, CARTELACreateArgs<ExtArgs>>): Prisma__CARTELAClient<$Result.GetResult<Prisma.$CARTELAPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CARTELAS.
     * @param {CARTELACreateManyArgs} args - Arguments to create many CARTELAS.
     * @example
     * // Create many CARTELAS
     * const cARTELA = await prisma.cARTELA.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CARTELACreateManyArgs>(args?: SelectSubset<T, CARTELACreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CARTELA.
     * @param {CARTELADeleteArgs} args - Arguments to delete one CARTELA.
     * @example
     * // Delete one CARTELA
     * const CARTELA = await prisma.cARTELA.delete({
     *   where: {
     *     // ... filter to delete one CARTELA
     *   }
     * })
     * 
     */
    delete<T extends CARTELADeleteArgs>(args: SelectSubset<T, CARTELADeleteArgs<ExtArgs>>): Prisma__CARTELAClient<$Result.GetResult<Prisma.$CARTELAPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CARTELA.
     * @param {CARTELAUpdateArgs} args - Arguments to update one CARTELA.
     * @example
     * // Update one CARTELA
     * const cARTELA = await prisma.cARTELA.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CARTELAUpdateArgs>(args: SelectSubset<T, CARTELAUpdateArgs<ExtArgs>>): Prisma__CARTELAClient<$Result.GetResult<Prisma.$CARTELAPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CARTELAS.
     * @param {CARTELADeleteManyArgs} args - Arguments to filter CARTELAS to delete.
     * @example
     * // Delete a few CARTELAS
     * const { count } = await prisma.cARTELA.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CARTELADeleteManyArgs>(args?: SelectSubset<T, CARTELADeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CARTELAS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CARTELAUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CARTELAS
     * const cARTELA = await prisma.cARTELA.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CARTELAUpdateManyArgs>(args: SelectSubset<T, CARTELAUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CARTELA.
     * @param {CARTELAUpsertArgs} args - Arguments to update or create a CARTELA.
     * @example
     * // Update or create a CARTELA
     * const cARTELA = await prisma.cARTELA.upsert({
     *   create: {
     *     // ... data to create a CARTELA
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CARTELA we want to update
     *   }
     * })
     */
    upsert<T extends CARTELAUpsertArgs>(args: SelectSubset<T, CARTELAUpsertArgs<ExtArgs>>): Prisma__CARTELAClient<$Result.GetResult<Prisma.$CARTELAPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CARTELAS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CARTELACountArgs} args - Arguments to filter CARTELAS to count.
     * @example
     * // Count the number of CARTELAS
     * const count = await prisma.cARTELA.count({
     *   where: {
     *     // ... the filter for the CARTELAS we want to count
     *   }
     * })
    **/
    count<T extends CARTELACountArgs>(
      args?: Subset<T, CARTELACountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CARTELACountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CARTELA.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CARTELAAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CARTELAAggregateArgs>(args: Subset<T, CARTELAAggregateArgs>): Prisma.PrismaPromise<GetCARTELAAggregateType<T>>

    /**
     * Group by CARTELA.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CARTELAGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CARTELAGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CARTELAGroupByArgs['orderBy'] }
        : { orderBy?: CARTELAGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CARTELAGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCARTELAGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CARTELA model
   */
  readonly fields: CARTELAFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CARTELA.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CARTELAClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    JOGO<T extends JOGODefaultArgs<ExtArgs> = {}>(args?: Subset<T, JOGODefaultArgs<ExtArgs>>): Prisma__JOGOClient<$Result.GetResult<Prisma.$JOGOPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    USUARIO<T extends USUARIODefaultArgs<ExtArgs> = {}>(args?: Subset<T, USUARIODefaultArgs<ExtArgs>>): Prisma__USUARIOClient<$Result.GetResult<Prisma.$USUARIOPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    NUMEROS_CARTELA<T extends CARTELA$NUMEROS_CARTELAArgs<ExtArgs> = {}>(args?: Subset<T, CARTELA$NUMEROS_CARTELAArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NUMEROS_CARTELAPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CARTELA model
   */
  interface CARTELAFieldRefs {
    readonly id_cartela: FieldRef<"CARTELA", 'Int'>
    readonly id_usuario: FieldRef<"CARTELA", 'Int'>
    readonly id_jogo: FieldRef<"CARTELA", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * CARTELA findUnique
   */
  export type CARTELAFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CARTELA
     */
    select?: CARTELASelect<ExtArgs> | null
    /**
     * Omit specific fields from the CARTELA
     */
    omit?: CARTELAOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CARTELAInclude<ExtArgs> | null
    /**
     * Filter, which CARTELA to fetch.
     */
    where: CARTELAWhereUniqueInput
  }

  /**
   * CARTELA findUniqueOrThrow
   */
  export type CARTELAFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CARTELA
     */
    select?: CARTELASelect<ExtArgs> | null
    /**
     * Omit specific fields from the CARTELA
     */
    omit?: CARTELAOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CARTELAInclude<ExtArgs> | null
    /**
     * Filter, which CARTELA to fetch.
     */
    where: CARTELAWhereUniqueInput
  }

  /**
   * CARTELA findFirst
   */
  export type CARTELAFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CARTELA
     */
    select?: CARTELASelect<ExtArgs> | null
    /**
     * Omit specific fields from the CARTELA
     */
    omit?: CARTELAOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CARTELAInclude<ExtArgs> | null
    /**
     * Filter, which CARTELA to fetch.
     */
    where?: CARTELAWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CARTELAS to fetch.
     */
    orderBy?: CARTELAOrderByWithRelationInput | CARTELAOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CARTELAS.
     */
    cursor?: CARTELAWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CARTELAS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CARTELAS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CARTELAS.
     */
    distinct?: CARTELAScalarFieldEnum | CARTELAScalarFieldEnum[]
  }

  /**
   * CARTELA findFirstOrThrow
   */
  export type CARTELAFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CARTELA
     */
    select?: CARTELASelect<ExtArgs> | null
    /**
     * Omit specific fields from the CARTELA
     */
    omit?: CARTELAOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CARTELAInclude<ExtArgs> | null
    /**
     * Filter, which CARTELA to fetch.
     */
    where?: CARTELAWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CARTELAS to fetch.
     */
    orderBy?: CARTELAOrderByWithRelationInput | CARTELAOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CARTELAS.
     */
    cursor?: CARTELAWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CARTELAS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CARTELAS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CARTELAS.
     */
    distinct?: CARTELAScalarFieldEnum | CARTELAScalarFieldEnum[]
  }

  /**
   * CARTELA findMany
   */
  export type CARTELAFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CARTELA
     */
    select?: CARTELASelect<ExtArgs> | null
    /**
     * Omit specific fields from the CARTELA
     */
    omit?: CARTELAOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CARTELAInclude<ExtArgs> | null
    /**
     * Filter, which CARTELAS to fetch.
     */
    where?: CARTELAWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CARTELAS to fetch.
     */
    orderBy?: CARTELAOrderByWithRelationInput | CARTELAOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CARTELAS.
     */
    cursor?: CARTELAWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CARTELAS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CARTELAS.
     */
    skip?: number
    distinct?: CARTELAScalarFieldEnum | CARTELAScalarFieldEnum[]
  }

  /**
   * CARTELA create
   */
  export type CARTELACreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CARTELA
     */
    select?: CARTELASelect<ExtArgs> | null
    /**
     * Omit specific fields from the CARTELA
     */
    omit?: CARTELAOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CARTELAInclude<ExtArgs> | null
    /**
     * The data needed to create a CARTELA.
     */
    data: XOR<CARTELACreateInput, CARTELAUncheckedCreateInput>
  }

  /**
   * CARTELA createMany
   */
  export type CARTELACreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CARTELAS.
     */
    data: CARTELACreateManyInput | CARTELACreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CARTELA update
   */
  export type CARTELAUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CARTELA
     */
    select?: CARTELASelect<ExtArgs> | null
    /**
     * Omit specific fields from the CARTELA
     */
    omit?: CARTELAOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CARTELAInclude<ExtArgs> | null
    /**
     * The data needed to update a CARTELA.
     */
    data: XOR<CARTELAUpdateInput, CARTELAUncheckedUpdateInput>
    /**
     * Choose, which CARTELA to update.
     */
    where: CARTELAWhereUniqueInput
  }

  /**
   * CARTELA updateMany
   */
  export type CARTELAUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CARTELAS.
     */
    data: XOR<CARTELAUpdateManyMutationInput, CARTELAUncheckedUpdateManyInput>
    /**
     * Filter which CARTELAS to update
     */
    where?: CARTELAWhereInput
    /**
     * Limit how many CARTELAS to update.
     */
    limit?: number
  }

  /**
   * CARTELA upsert
   */
  export type CARTELAUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CARTELA
     */
    select?: CARTELASelect<ExtArgs> | null
    /**
     * Omit specific fields from the CARTELA
     */
    omit?: CARTELAOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CARTELAInclude<ExtArgs> | null
    /**
     * The filter to search for the CARTELA to update in case it exists.
     */
    where: CARTELAWhereUniqueInput
    /**
     * In case the CARTELA found by the `where` argument doesn't exist, create a new CARTELA with this data.
     */
    create: XOR<CARTELACreateInput, CARTELAUncheckedCreateInput>
    /**
     * In case the CARTELA was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CARTELAUpdateInput, CARTELAUncheckedUpdateInput>
  }

  /**
   * CARTELA delete
   */
  export type CARTELADeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CARTELA
     */
    select?: CARTELASelect<ExtArgs> | null
    /**
     * Omit specific fields from the CARTELA
     */
    omit?: CARTELAOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CARTELAInclude<ExtArgs> | null
    /**
     * Filter which CARTELA to delete.
     */
    where: CARTELAWhereUniqueInput
  }

  /**
   * CARTELA deleteMany
   */
  export type CARTELADeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CARTELAS to delete
     */
    where?: CARTELAWhereInput
    /**
     * Limit how many CARTELAS to delete.
     */
    limit?: number
  }

  /**
   * CARTELA.NUMEROS_CARTELA
   */
  export type CARTELA$NUMEROS_CARTELAArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NUMEROS_CARTELA
     */
    select?: NUMEROS_CARTELASelect<ExtArgs> | null
    /**
     * Omit specific fields from the NUMEROS_CARTELA
     */
    omit?: NUMEROS_CARTELAOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NUMEROS_CARTELAInclude<ExtArgs> | null
    where?: NUMEROS_CARTELAWhereInput
    orderBy?: NUMEROS_CARTELAOrderByWithRelationInput | NUMEROS_CARTELAOrderByWithRelationInput[]
    cursor?: NUMEROS_CARTELAWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NUMEROS_CARTELAScalarFieldEnum | NUMEROS_CARTELAScalarFieldEnum[]
  }

  /**
   * CARTELA without action
   */
  export type CARTELADefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CARTELA
     */
    select?: CARTELASelect<ExtArgs> | null
    /**
     * Omit specific fields from the CARTELA
     */
    omit?: CARTELAOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CARTELAInclude<ExtArgs> | null
  }


  /**
   * Model JOGO
   */

  export type AggregateJOGO = {
    _count: JOGOCountAggregateOutputType | null
    _avg: JOGOAvgAggregateOutputType | null
    _sum: JOGOSumAggregateOutputType | null
    _min: JOGOMinAggregateOutputType | null
    _max: JOGOMaxAggregateOutputType | null
  }

  export type JOGOAvgAggregateOutputType = {
    id_jogo: number | null
    id_sala: number | null
    id_usuario_vencedor: number | null
    preco_cartela: Decimal | null
  }

  export type JOGOSumAggregateOutputType = {
    id_jogo: number | null
    id_sala: number | null
    id_usuario_vencedor: number | null
    preco_cartela: Decimal | null
  }

  export type JOGOMinAggregateOutputType = {
    id_jogo: number | null
    data_hora: Date | null
    id_sala: number | null
    id_usuario_vencedor: number | null
    preco_cartela: Decimal | null
  }

  export type JOGOMaxAggregateOutputType = {
    id_jogo: number | null
    data_hora: Date | null
    id_sala: number | null
    id_usuario_vencedor: number | null
    preco_cartela: Decimal | null
  }

  export type JOGOCountAggregateOutputType = {
    id_jogo: number
    data_hora: number
    id_sala: number
    id_usuario_vencedor: number
    preco_cartela: number
    _all: number
  }


  export type JOGOAvgAggregateInputType = {
    id_jogo?: true
    id_sala?: true
    id_usuario_vencedor?: true
    preco_cartela?: true
  }

  export type JOGOSumAggregateInputType = {
    id_jogo?: true
    id_sala?: true
    id_usuario_vencedor?: true
    preco_cartela?: true
  }

  export type JOGOMinAggregateInputType = {
    id_jogo?: true
    data_hora?: true
    id_sala?: true
    id_usuario_vencedor?: true
    preco_cartela?: true
  }

  export type JOGOMaxAggregateInputType = {
    id_jogo?: true
    data_hora?: true
    id_sala?: true
    id_usuario_vencedor?: true
    preco_cartela?: true
  }

  export type JOGOCountAggregateInputType = {
    id_jogo?: true
    data_hora?: true
    id_sala?: true
    id_usuario_vencedor?: true
    preco_cartela?: true
    _all?: true
  }

  export type JOGOAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JOGO to aggregate.
     */
    where?: JOGOWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JOGOS to fetch.
     */
    orderBy?: JOGOOrderByWithRelationInput | JOGOOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: JOGOWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JOGOS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JOGOS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned JOGOS
    **/
    _count?: true | JOGOCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: JOGOAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: JOGOSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: JOGOMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: JOGOMaxAggregateInputType
  }

  export type GetJOGOAggregateType<T extends JOGOAggregateArgs> = {
        [P in keyof T & keyof AggregateJOGO]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateJOGO[P]>
      : GetScalarType<T[P], AggregateJOGO[P]>
  }




  export type JOGOGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JOGOWhereInput
    orderBy?: JOGOOrderByWithAggregationInput | JOGOOrderByWithAggregationInput[]
    by: JOGOScalarFieldEnum[] | JOGOScalarFieldEnum
    having?: JOGOScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: JOGOCountAggregateInputType | true
    _avg?: JOGOAvgAggregateInputType
    _sum?: JOGOSumAggregateInputType
    _min?: JOGOMinAggregateInputType
    _max?: JOGOMaxAggregateInputType
  }

  export type JOGOGroupByOutputType = {
    id_jogo: number
    data_hora: Date
    id_sala: number
    id_usuario_vencedor: number | null
    preco_cartela: Decimal
    _count: JOGOCountAggregateOutputType | null
    _avg: JOGOAvgAggregateOutputType | null
    _sum: JOGOSumAggregateOutputType | null
    _min: JOGOMinAggregateOutputType | null
    _max: JOGOMaxAggregateOutputType | null
  }

  type GetJOGOGroupByPayload<T extends JOGOGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<JOGOGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof JOGOGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], JOGOGroupByOutputType[P]>
            : GetScalarType<T[P], JOGOGroupByOutputType[P]>
        }
      >
    >


  export type JOGOSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_jogo?: boolean
    data_hora?: boolean
    id_sala?: boolean
    id_usuario_vencedor?: boolean
    preco_cartela?: boolean
    CARTELA?: boolean | JOGO$CARTELAArgs<ExtArgs>
    SALA?: boolean | SALADefaultArgs<ExtArgs>
    USUARIO?: boolean | JOGO$USUARIOArgs<ExtArgs>
    NUMEROS_SORTEADOS?: boolean | JOGO$NUMEROS_SORTEADOSArgs<ExtArgs>
    PREMIOS?: boolean | JOGO$PREMIOSArgs<ExtArgs>
    _count?: boolean | JOGOCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["jOGO"]>



  export type JOGOSelectScalar = {
    id_jogo?: boolean
    data_hora?: boolean
    id_sala?: boolean
    id_usuario_vencedor?: boolean
    preco_cartela?: boolean
  }

  export type JOGOOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id_jogo" | "data_hora" | "id_sala" | "id_usuario_vencedor" | "preco_cartela", ExtArgs["result"]["jOGO"]>
  export type JOGOInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    CARTELA?: boolean | JOGO$CARTELAArgs<ExtArgs>
    SALA?: boolean | SALADefaultArgs<ExtArgs>
    USUARIO?: boolean | JOGO$USUARIOArgs<ExtArgs>
    NUMEROS_SORTEADOS?: boolean | JOGO$NUMEROS_SORTEADOSArgs<ExtArgs>
    PREMIOS?: boolean | JOGO$PREMIOSArgs<ExtArgs>
    _count?: boolean | JOGOCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $JOGOPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "JOGO"
    objects: {
      CARTELA: Prisma.$CARTELAPayload<ExtArgs>[]
      SALA: Prisma.$SALAPayload<ExtArgs>
      USUARIO: Prisma.$USUARIOPayload<ExtArgs> | null
      NUMEROS_SORTEADOS: Prisma.$NUMEROS_SORTEADOSPayload<ExtArgs>[]
      PREMIOS: Prisma.$PREMIOSPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id_jogo: number
      data_hora: Date
      id_sala: number
      id_usuario_vencedor: number | null
      preco_cartela: Prisma.Decimal
    }, ExtArgs["result"]["jOGO"]>
    composites: {}
  }

  type JOGOGetPayload<S extends boolean | null | undefined | JOGODefaultArgs> = $Result.GetResult<Prisma.$JOGOPayload, S>

  type JOGOCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<JOGOFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: JOGOCountAggregateInputType | true
    }

  export interface JOGODelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['JOGO'], meta: { name: 'JOGO' } }
    /**
     * Find zero or one JOGO that matches the filter.
     * @param {JOGOFindUniqueArgs} args - Arguments to find a JOGO
     * @example
     * // Get one JOGO
     * const jOGO = await prisma.jOGO.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends JOGOFindUniqueArgs>(args: SelectSubset<T, JOGOFindUniqueArgs<ExtArgs>>): Prisma__JOGOClient<$Result.GetResult<Prisma.$JOGOPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one JOGO that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {JOGOFindUniqueOrThrowArgs} args - Arguments to find a JOGO
     * @example
     * // Get one JOGO
     * const jOGO = await prisma.jOGO.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends JOGOFindUniqueOrThrowArgs>(args: SelectSubset<T, JOGOFindUniqueOrThrowArgs<ExtArgs>>): Prisma__JOGOClient<$Result.GetResult<Prisma.$JOGOPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first JOGO that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JOGOFindFirstArgs} args - Arguments to find a JOGO
     * @example
     * // Get one JOGO
     * const jOGO = await prisma.jOGO.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends JOGOFindFirstArgs>(args?: SelectSubset<T, JOGOFindFirstArgs<ExtArgs>>): Prisma__JOGOClient<$Result.GetResult<Prisma.$JOGOPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first JOGO that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JOGOFindFirstOrThrowArgs} args - Arguments to find a JOGO
     * @example
     * // Get one JOGO
     * const jOGO = await prisma.jOGO.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends JOGOFindFirstOrThrowArgs>(args?: SelectSubset<T, JOGOFindFirstOrThrowArgs<ExtArgs>>): Prisma__JOGOClient<$Result.GetResult<Prisma.$JOGOPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more JOGOS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JOGOFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all JOGOS
     * const jOGOS = await prisma.jOGO.findMany()
     * 
     * // Get first 10 JOGOS
     * const jOGOS = await prisma.jOGO.findMany({ take: 10 })
     * 
     * // Only select the `id_jogo`
     * const jOGOWithId_jogoOnly = await prisma.jOGO.findMany({ select: { id_jogo: true } })
     * 
     */
    findMany<T extends JOGOFindManyArgs>(args?: SelectSubset<T, JOGOFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JOGOPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a JOGO.
     * @param {JOGOCreateArgs} args - Arguments to create a JOGO.
     * @example
     * // Create one JOGO
     * const JOGO = await prisma.jOGO.create({
     *   data: {
     *     // ... data to create a JOGO
     *   }
     * })
     * 
     */
    create<T extends JOGOCreateArgs>(args: SelectSubset<T, JOGOCreateArgs<ExtArgs>>): Prisma__JOGOClient<$Result.GetResult<Prisma.$JOGOPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many JOGOS.
     * @param {JOGOCreateManyArgs} args - Arguments to create many JOGOS.
     * @example
     * // Create many JOGOS
     * const jOGO = await prisma.jOGO.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends JOGOCreateManyArgs>(args?: SelectSubset<T, JOGOCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a JOGO.
     * @param {JOGODeleteArgs} args - Arguments to delete one JOGO.
     * @example
     * // Delete one JOGO
     * const JOGO = await prisma.jOGO.delete({
     *   where: {
     *     // ... filter to delete one JOGO
     *   }
     * })
     * 
     */
    delete<T extends JOGODeleteArgs>(args: SelectSubset<T, JOGODeleteArgs<ExtArgs>>): Prisma__JOGOClient<$Result.GetResult<Prisma.$JOGOPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one JOGO.
     * @param {JOGOUpdateArgs} args - Arguments to update one JOGO.
     * @example
     * // Update one JOGO
     * const jOGO = await prisma.jOGO.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends JOGOUpdateArgs>(args: SelectSubset<T, JOGOUpdateArgs<ExtArgs>>): Prisma__JOGOClient<$Result.GetResult<Prisma.$JOGOPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more JOGOS.
     * @param {JOGODeleteManyArgs} args - Arguments to filter JOGOS to delete.
     * @example
     * // Delete a few JOGOS
     * const { count } = await prisma.jOGO.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends JOGODeleteManyArgs>(args?: SelectSubset<T, JOGODeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more JOGOS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JOGOUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many JOGOS
     * const jOGO = await prisma.jOGO.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends JOGOUpdateManyArgs>(args: SelectSubset<T, JOGOUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one JOGO.
     * @param {JOGOUpsertArgs} args - Arguments to update or create a JOGO.
     * @example
     * // Update or create a JOGO
     * const jOGO = await prisma.jOGO.upsert({
     *   create: {
     *     // ... data to create a JOGO
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the JOGO we want to update
     *   }
     * })
     */
    upsert<T extends JOGOUpsertArgs>(args: SelectSubset<T, JOGOUpsertArgs<ExtArgs>>): Prisma__JOGOClient<$Result.GetResult<Prisma.$JOGOPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of JOGOS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JOGOCountArgs} args - Arguments to filter JOGOS to count.
     * @example
     * // Count the number of JOGOS
     * const count = await prisma.jOGO.count({
     *   where: {
     *     // ... the filter for the JOGOS we want to count
     *   }
     * })
    **/
    count<T extends JOGOCountArgs>(
      args?: Subset<T, JOGOCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], JOGOCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a JOGO.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JOGOAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends JOGOAggregateArgs>(args: Subset<T, JOGOAggregateArgs>): Prisma.PrismaPromise<GetJOGOAggregateType<T>>

    /**
     * Group by JOGO.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JOGOGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends JOGOGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: JOGOGroupByArgs['orderBy'] }
        : { orderBy?: JOGOGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, JOGOGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetJOGOGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the JOGO model
   */
  readonly fields: JOGOFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for JOGO.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__JOGOClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    CARTELA<T extends JOGO$CARTELAArgs<ExtArgs> = {}>(args?: Subset<T, JOGO$CARTELAArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CARTELAPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    SALA<T extends SALADefaultArgs<ExtArgs> = {}>(args?: Subset<T, SALADefaultArgs<ExtArgs>>): Prisma__SALAClient<$Result.GetResult<Prisma.$SALAPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    USUARIO<T extends JOGO$USUARIOArgs<ExtArgs> = {}>(args?: Subset<T, JOGO$USUARIOArgs<ExtArgs>>): Prisma__USUARIOClient<$Result.GetResult<Prisma.$USUARIOPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    NUMEROS_SORTEADOS<T extends JOGO$NUMEROS_SORTEADOSArgs<ExtArgs> = {}>(args?: Subset<T, JOGO$NUMEROS_SORTEADOSArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NUMEROS_SORTEADOSPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    PREMIOS<T extends JOGO$PREMIOSArgs<ExtArgs> = {}>(args?: Subset<T, JOGO$PREMIOSArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PREMIOSPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the JOGO model
   */
  interface JOGOFieldRefs {
    readonly id_jogo: FieldRef<"JOGO", 'Int'>
    readonly data_hora: FieldRef<"JOGO", 'DateTime'>
    readonly id_sala: FieldRef<"JOGO", 'Int'>
    readonly id_usuario_vencedor: FieldRef<"JOGO", 'Int'>
    readonly preco_cartela: FieldRef<"JOGO", 'Decimal'>
  }
    

  // Custom InputTypes
  /**
   * JOGO findUnique
   */
  export type JOGOFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JOGO
     */
    select?: JOGOSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JOGO
     */
    omit?: JOGOOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JOGOInclude<ExtArgs> | null
    /**
     * Filter, which JOGO to fetch.
     */
    where: JOGOWhereUniqueInput
  }

  /**
   * JOGO findUniqueOrThrow
   */
  export type JOGOFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JOGO
     */
    select?: JOGOSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JOGO
     */
    omit?: JOGOOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JOGOInclude<ExtArgs> | null
    /**
     * Filter, which JOGO to fetch.
     */
    where: JOGOWhereUniqueInput
  }

  /**
   * JOGO findFirst
   */
  export type JOGOFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JOGO
     */
    select?: JOGOSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JOGO
     */
    omit?: JOGOOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JOGOInclude<ExtArgs> | null
    /**
     * Filter, which JOGO to fetch.
     */
    where?: JOGOWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JOGOS to fetch.
     */
    orderBy?: JOGOOrderByWithRelationInput | JOGOOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JOGOS.
     */
    cursor?: JOGOWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JOGOS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JOGOS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JOGOS.
     */
    distinct?: JOGOScalarFieldEnum | JOGOScalarFieldEnum[]
  }

  /**
   * JOGO findFirstOrThrow
   */
  export type JOGOFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JOGO
     */
    select?: JOGOSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JOGO
     */
    omit?: JOGOOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JOGOInclude<ExtArgs> | null
    /**
     * Filter, which JOGO to fetch.
     */
    where?: JOGOWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JOGOS to fetch.
     */
    orderBy?: JOGOOrderByWithRelationInput | JOGOOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JOGOS.
     */
    cursor?: JOGOWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JOGOS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JOGOS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JOGOS.
     */
    distinct?: JOGOScalarFieldEnum | JOGOScalarFieldEnum[]
  }

  /**
   * JOGO findMany
   */
  export type JOGOFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JOGO
     */
    select?: JOGOSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JOGO
     */
    omit?: JOGOOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JOGOInclude<ExtArgs> | null
    /**
     * Filter, which JOGOS to fetch.
     */
    where?: JOGOWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JOGOS to fetch.
     */
    orderBy?: JOGOOrderByWithRelationInput | JOGOOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing JOGOS.
     */
    cursor?: JOGOWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JOGOS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JOGOS.
     */
    skip?: number
    distinct?: JOGOScalarFieldEnum | JOGOScalarFieldEnum[]
  }

  /**
   * JOGO create
   */
  export type JOGOCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JOGO
     */
    select?: JOGOSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JOGO
     */
    omit?: JOGOOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JOGOInclude<ExtArgs> | null
    /**
     * The data needed to create a JOGO.
     */
    data: XOR<JOGOCreateInput, JOGOUncheckedCreateInput>
  }

  /**
   * JOGO createMany
   */
  export type JOGOCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many JOGOS.
     */
    data: JOGOCreateManyInput | JOGOCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * JOGO update
   */
  export type JOGOUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JOGO
     */
    select?: JOGOSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JOGO
     */
    omit?: JOGOOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JOGOInclude<ExtArgs> | null
    /**
     * The data needed to update a JOGO.
     */
    data: XOR<JOGOUpdateInput, JOGOUncheckedUpdateInput>
    /**
     * Choose, which JOGO to update.
     */
    where: JOGOWhereUniqueInput
  }

  /**
   * JOGO updateMany
   */
  export type JOGOUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update JOGOS.
     */
    data: XOR<JOGOUpdateManyMutationInput, JOGOUncheckedUpdateManyInput>
    /**
     * Filter which JOGOS to update
     */
    where?: JOGOWhereInput
    /**
     * Limit how many JOGOS to update.
     */
    limit?: number
  }

  /**
   * JOGO upsert
   */
  export type JOGOUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JOGO
     */
    select?: JOGOSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JOGO
     */
    omit?: JOGOOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JOGOInclude<ExtArgs> | null
    /**
     * The filter to search for the JOGO to update in case it exists.
     */
    where: JOGOWhereUniqueInput
    /**
     * In case the JOGO found by the `where` argument doesn't exist, create a new JOGO with this data.
     */
    create: XOR<JOGOCreateInput, JOGOUncheckedCreateInput>
    /**
     * In case the JOGO was found with the provided `where` argument, update it with this data.
     */
    update: XOR<JOGOUpdateInput, JOGOUncheckedUpdateInput>
  }

  /**
   * JOGO delete
   */
  export type JOGODeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JOGO
     */
    select?: JOGOSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JOGO
     */
    omit?: JOGOOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JOGOInclude<ExtArgs> | null
    /**
     * Filter which JOGO to delete.
     */
    where: JOGOWhereUniqueInput
  }

  /**
   * JOGO deleteMany
   */
  export type JOGODeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JOGOS to delete
     */
    where?: JOGOWhereInput
    /**
     * Limit how many JOGOS to delete.
     */
    limit?: number
  }

  /**
   * JOGO.CARTELA
   */
  export type JOGO$CARTELAArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CARTELA
     */
    select?: CARTELASelect<ExtArgs> | null
    /**
     * Omit specific fields from the CARTELA
     */
    omit?: CARTELAOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CARTELAInclude<ExtArgs> | null
    where?: CARTELAWhereInput
    orderBy?: CARTELAOrderByWithRelationInput | CARTELAOrderByWithRelationInput[]
    cursor?: CARTELAWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CARTELAScalarFieldEnum | CARTELAScalarFieldEnum[]
  }

  /**
   * JOGO.USUARIO
   */
  export type JOGO$USUARIOArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the USUARIO
     */
    select?: USUARIOSelect<ExtArgs> | null
    /**
     * Omit specific fields from the USUARIO
     */
    omit?: USUARIOOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: USUARIOInclude<ExtArgs> | null
    where?: USUARIOWhereInput
  }

  /**
   * JOGO.NUMEROS_SORTEADOS
   */
  export type JOGO$NUMEROS_SORTEADOSArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NUMEROS_SORTEADOS
     */
    select?: NUMEROS_SORTEADOSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NUMEROS_SORTEADOS
     */
    omit?: NUMEROS_SORTEADOSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NUMEROS_SORTEADOSInclude<ExtArgs> | null
    where?: NUMEROS_SORTEADOSWhereInput
    orderBy?: NUMEROS_SORTEADOSOrderByWithRelationInput | NUMEROS_SORTEADOSOrderByWithRelationInput[]
    cursor?: NUMEROS_SORTEADOSWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NUMEROS_SORTEADOSScalarFieldEnum | NUMEROS_SORTEADOSScalarFieldEnum[]
  }

  /**
   * JOGO.PREMIOS
   */
  export type JOGO$PREMIOSArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PREMIOS
     */
    select?: PREMIOSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PREMIOS
     */
    omit?: PREMIOSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PREMIOSInclude<ExtArgs> | null
    where?: PREMIOSWhereInput
    orderBy?: PREMIOSOrderByWithRelationInput | PREMIOSOrderByWithRelationInput[]
    cursor?: PREMIOSWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PREMIOSScalarFieldEnum | PREMIOSScalarFieldEnum[]
  }

  /**
   * JOGO without action
   */
  export type JOGODefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JOGO
     */
    select?: JOGOSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JOGO
     */
    omit?: JOGOOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JOGOInclude<ExtArgs> | null
  }


  /**
   * Model NUMEROS_CARTELA
   */

  export type AggregateNUMEROS_CARTELA = {
    _count: NUMEROS_CARTELACountAggregateOutputType | null
    _avg: NUMEROS_CARTELAAvgAggregateOutputType | null
    _sum: NUMEROS_CARTELASumAggregateOutputType | null
    _min: NUMEROS_CARTELAMinAggregateOutputType | null
    _max: NUMEROS_CARTELAMaxAggregateOutputType | null
  }

  export type NUMEROS_CARTELAAvgAggregateOutputType = {
    id_numero_cartela: number | null
    numero: number | null
    id_cartela: number | null
  }

  export type NUMEROS_CARTELASumAggregateOutputType = {
    id_numero_cartela: number | null
    numero: number | null
    id_cartela: number | null
  }

  export type NUMEROS_CARTELAMinAggregateOutputType = {
    id_numero_cartela: number | null
    numero: number | null
    id_cartela: number | null
  }

  export type NUMEROS_CARTELAMaxAggregateOutputType = {
    id_numero_cartela: number | null
    numero: number | null
    id_cartela: number | null
  }

  export type NUMEROS_CARTELACountAggregateOutputType = {
    id_numero_cartela: number
    numero: number
    id_cartela: number
    _all: number
  }


  export type NUMEROS_CARTELAAvgAggregateInputType = {
    id_numero_cartela?: true
    numero?: true
    id_cartela?: true
  }

  export type NUMEROS_CARTELASumAggregateInputType = {
    id_numero_cartela?: true
    numero?: true
    id_cartela?: true
  }

  export type NUMEROS_CARTELAMinAggregateInputType = {
    id_numero_cartela?: true
    numero?: true
    id_cartela?: true
  }

  export type NUMEROS_CARTELAMaxAggregateInputType = {
    id_numero_cartela?: true
    numero?: true
    id_cartela?: true
  }

  export type NUMEROS_CARTELACountAggregateInputType = {
    id_numero_cartela?: true
    numero?: true
    id_cartela?: true
    _all?: true
  }

  export type NUMEROS_CARTELAAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NUMEROS_CARTELA to aggregate.
     */
    where?: NUMEROS_CARTELAWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NUMEROS_CARTELAS to fetch.
     */
    orderBy?: NUMEROS_CARTELAOrderByWithRelationInput | NUMEROS_CARTELAOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NUMEROS_CARTELAWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NUMEROS_CARTELAS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NUMEROS_CARTELAS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NUMEROS_CARTELAS
    **/
    _count?: true | NUMEROS_CARTELACountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NUMEROS_CARTELAAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NUMEROS_CARTELASumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NUMEROS_CARTELAMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NUMEROS_CARTELAMaxAggregateInputType
  }

  export type GetNUMEROS_CARTELAAggregateType<T extends NUMEROS_CARTELAAggregateArgs> = {
        [P in keyof T & keyof AggregateNUMEROS_CARTELA]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNUMEROS_CARTELA[P]>
      : GetScalarType<T[P], AggregateNUMEROS_CARTELA[P]>
  }




  export type NUMEROS_CARTELAGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NUMEROS_CARTELAWhereInput
    orderBy?: NUMEROS_CARTELAOrderByWithAggregationInput | NUMEROS_CARTELAOrderByWithAggregationInput[]
    by: NUMEROS_CARTELAScalarFieldEnum[] | NUMEROS_CARTELAScalarFieldEnum
    having?: NUMEROS_CARTELAScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NUMEROS_CARTELACountAggregateInputType | true
    _avg?: NUMEROS_CARTELAAvgAggregateInputType
    _sum?: NUMEROS_CARTELASumAggregateInputType
    _min?: NUMEROS_CARTELAMinAggregateInputType
    _max?: NUMEROS_CARTELAMaxAggregateInputType
  }

  export type NUMEROS_CARTELAGroupByOutputType = {
    id_numero_cartela: number
    numero: number
    id_cartela: number
    _count: NUMEROS_CARTELACountAggregateOutputType | null
    _avg: NUMEROS_CARTELAAvgAggregateOutputType | null
    _sum: NUMEROS_CARTELASumAggregateOutputType | null
    _min: NUMEROS_CARTELAMinAggregateOutputType | null
    _max: NUMEROS_CARTELAMaxAggregateOutputType | null
  }

  type GetNUMEROS_CARTELAGroupByPayload<T extends NUMEROS_CARTELAGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NUMEROS_CARTELAGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NUMEROS_CARTELAGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NUMEROS_CARTELAGroupByOutputType[P]>
            : GetScalarType<T[P], NUMEROS_CARTELAGroupByOutputType[P]>
        }
      >
    >


  export type NUMEROS_CARTELASelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_numero_cartela?: boolean
    numero?: boolean
    id_cartela?: boolean
    CARTELA?: boolean | CARTELADefaultArgs<ExtArgs>
  }, ExtArgs["result"]["nUMEROS_CARTELA"]>



  export type NUMEROS_CARTELASelectScalar = {
    id_numero_cartela?: boolean
    numero?: boolean
    id_cartela?: boolean
  }

  export type NUMEROS_CARTELAOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id_numero_cartela" | "numero" | "id_cartela", ExtArgs["result"]["nUMEROS_CARTELA"]>
  export type NUMEROS_CARTELAInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    CARTELA?: boolean | CARTELADefaultArgs<ExtArgs>
  }

  export type $NUMEROS_CARTELAPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NUMEROS_CARTELA"
    objects: {
      CARTELA: Prisma.$CARTELAPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id_numero_cartela: number
      numero: number
      id_cartela: number
    }, ExtArgs["result"]["nUMEROS_CARTELA"]>
    composites: {}
  }

  type NUMEROS_CARTELAGetPayload<S extends boolean | null | undefined | NUMEROS_CARTELADefaultArgs> = $Result.GetResult<Prisma.$NUMEROS_CARTELAPayload, S>

  type NUMEROS_CARTELACountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NUMEROS_CARTELAFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NUMEROS_CARTELACountAggregateInputType | true
    }

  export interface NUMEROS_CARTELADelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NUMEROS_CARTELA'], meta: { name: 'NUMEROS_CARTELA' } }
    /**
     * Find zero or one NUMEROS_CARTELA that matches the filter.
     * @param {NUMEROS_CARTELAFindUniqueArgs} args - Arguments to find a NUMEROS_CARTELA
     * @example
     * // Get one NUMEROS_CARTELA
     * const nUMEROS_CARTELA = await prisma.nUMEROS_CARTELA.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NUMEROS_CARTELAFindUniqueArgs>(args: SelectSubset<T, NUMEROS_CARTELAFindUniqueArgs<ExtArgs>>): Prisma__NUMEROS_CARTELAClient<$Result.GetResult<Prisma.$NUMEROS_CARTELAPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one NUMEROS_CARTELA that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NUMEROS_CARTELAFindUniqueOrThrowArgs} args - Arguments to find a NUMEROS_CARTELA
     * @example
     * // Get one NUMEROS_CARTELA
     * const nUMEROS_CARTELA = await prisma.nUMEROS_CARTELA.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NUMEROS_CARTELAFindUniqueOrThrowArgs>(args: SelectSubset<T, NUMEROS_CARTELAFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NUMEROS_CARTELAClient<$Result.GetResult<Prisma.$NUMEROS_CARTELAPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NUMEROS_CARTELA that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NUMEROS_CARTELAFindFirstArgs} args - Arguments to find a NUMEROS_CARTELA
     * @example
     * // Get one NUMEROS_CARTELA
     * const nUMEROS_CARTELA = await prisma.nUMEROS_CARTELA.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NUMEROS_CARTELAFindFirstArgs>(args?: SelectSubset<T, NUMEROS_CARTELAFindFirstArgs<ExtArgs>>): Prisma__NUMEROS_CARTELAClient<$Result.GetResult<Prisma.$NUMEROS_CARTELAPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NUMEROS_CARTELA that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NUMEROS_CARTELAFindFirstOrThrowArgs} args - Arguments to find a NUMEROS_CARTELA
     * @example
     * // Get one NUMEROS_CARTELA
     * const nUMEROS_CARTELA = await prisma.nUMEROS_CARTELA.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NUMEROS_CARTELAFindFirstOrThrowArgs>(args?: SelectSubset<T, NUMEROS_CARTELAFindFirstOrThrowArgs<ExtArgs>>): Prisma__NUMEROS_CARTELAClient<$Result.GetResult<Prisma.$NUMEROS_CARTELAPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more NUMEROS_CARTELAS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NUMEROS_CARTELAFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NUMEROS_CARTELAS
     * const nUMEROS_CARTELAS = await prisma.nUMEROS_CARTELA.findMany()
     * 
     * // Get first 10 NUMEROS_CARTELAS
     * const nUMEROS_CARTELAS = await prisma.nUMEROS_CARTELA.findMany({ take: 10 })
     * 
     * // Only select the `id_numero_cartela`
     * const nUMEROS_CARTELAWithId_numero_cartelaOnly = await prisma.nUMEROS_CARTELA.findMany({ select: { id_numero_cartela: true } })
     * 
     */
    findMany<T extends NUMEROS_CARTELAFindManyArgs>(args?: SelectSubset<T, NUMEROS_CARTELAFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NUMEROS_CARTELAPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a NUMEROS_CARTELA.
     * @param {NUMEROS_CARTELACreateArgs} args - Arguments to create a NUMEROS_CARTELA.
     * @example
     * // Create one NUMEROS_CARTELA
     * const NUMEROS_CARTELA = await prisma.nUMEROS_CARTELA.create({
     *   data: {
     *     // ... data to create a NUMEROS_CARTELA
     *   }
     * })
     * 
     */
    create<T extends NUMEROS_CARTELACreateArgs>(args: SelectSubset<T, NUMEROS_CARTELACreateArgs<ExtArgs>>): Prisma__NUMEROS_CARTELAClient<$Result.GetResult<Prisma.$NUMEROS_CARTELAPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many NUMEROS_CARTELAS.
     * @param {NUMEROS_CARTELACreateManyArgs} args - Arguments to create many NUMEROS_CARTELAS.
     * @example
     * // Create many NUMEROS_CARTELAS
     * const nUMEROS_CARTELA = await prisma.nUMEROS_CARTELA.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NUMEROS_CARTELACreateManyArgs>(args?: SelectSubset<T, NUMEROS_CARTELACreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a NUMEROS_CARTELA.
     * @param {NUMEROS_CARTELADeleteArgs} args - Arguments to delete one NUMEROS_CARTELA.
     * @example
     * // Delete one NUMEROS_CARTELA
     * const NUMEROS_CARTELA = await prisma.nUMEROS_CARTELA.delete({
     *   where: {
     *     // ... filter to delete one NUMEROS_CARTELA
     *   }
     * })
     * 
     */
    delete<T extends NUMEROS_CARTELADeleteArgs>(args: SelectSubset<T, NUMEROS_CARTELADeleteArgs<ExtArgs>>): Prisma__NUMEROS_CARTELAClient<$Result.GetResult<Prisma.$NUMEROS_CARTELAPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one NUMEROS_CARTELA.
     * @param {NUMEROS_CARTELAUpdateArgs} args - Arguments to update one NUMEROS_CARTELA.
     * @example
     * // Update one NUMEROS_CARTELA
     * const nUMEROS_CARTELA = await prisma.nUMEROS_CARTELA.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NUMEROS_CARTELAUpdateArgs>(args: SelectSubset<T, NUMEROS_CARTELAUpdateArgs<ExtArgs>>): Prisma__NUMEROS_CARTELAClient<$Result.GetResult<Prisma.$NUMEROS_CARTELAPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more NUMEROS_CARTELAS.
     * @param {NUMEROS_CARTELADeleteManyArgs} args - Arguments to filter NUMEROS_CARTELAS to delete.
     * @example
     * // Delete a few NUMEROS_CARTELAS
     * const { count } = await prisma.nUMEROS_CARTELA.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NUMEROS_CARTELADeleteManyArgs>(args?: SelectSubset<T, NUMEROS_CARTELADeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NUMEROS_CARTELAS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NUMEROS_CARTELAUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NUMEROS_CARTELAS
     * const nUMEROS_CARTELA = await prisma.nUMEROS_CARTELA.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NUMEROS_CARTELAUpdateManyArgs>(args: SelectSubset<T, NUMEROS_CARTELAUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one NUMEROS_CARTELA.
     * @param {NUMEROS_CARTELAUpsertArgs} args - Arguments to update or create a NUMEROS_CARTELA.
     * @example
     * // Update or create a NUMEROS_CARTELA
     * const nUMEROS_CARTELA = await prisma.nUMEROS_CARTELA.upsert({
     *   create: {
     *     // ... data to create a NUMEROS_CARTELA
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NUMEROS_CARTELA we want to update
     *   }
     * })
     */
    upsert<T extends NUMEROS_CARTELAUpsertArgs>(args: SelectSubset<T, NUMEROS_CARTELAUpsertArgs<ExtArgs>>): Prisma__NUMEROS_CARTELAClient<$Result.GetResult<Prisma.$NUMEROS_CARTELAPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of NUMEROS_CARTELAS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NUMEROS_CARTELACountArgs} args - Arguments to filter NUMEROS_CARTELAS to count.
     * @example
     * // Count the number of NUMEROS_CARTELAS
     * const count = await prisma.nUMEROS_CARTELA.count({
     *   where: {
     *     // ... the filter for the NUMEROS_CARTELAS we want to count
     *   }
     * })
    **/
    count<T extends NUMEROS_CARTELACountArgs>(
      args?: Subset<T, NUMEROS_CARTELACountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NUMEROS_CARTELACountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NUMEROS_CARTELA.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NUMEROS_CARTELAAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NUMEROS_CARTELAAggregateArgs>(args: Subset<T, NUMEROS_CARTELAAggregateArgs>): Prisma.PrismaPromise<GetNUMEROS_CARTELAAggregateType<T>>

    /**
     * Group by NUMEROS_CARTELA.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NUMEROS_CARTELAGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NUMEROS_CARTELAGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NUMEROS_CARTELAGroupByArgs['orderBy'] }
        : { orderBy?: NUMEROS_CARTELAGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NUMEROS_CARTELAGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNUMEROS_CARTELAGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NUMEROS_CARTELA model
   */
  readonly fields: NUMEROS_CARTELAFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NUMEROS_CARTELA.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NUMEROS_CARTELAClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    CARTELA<T extends CARTELADefaultArgs<ExtArgs> = {}>(args?: Subset<T, CARTELADefaultArgs<ExtArgs>>): Prisma__CARTELAClient<$Result.GetResult<Prisma.$CARTELAPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the NUMEROS_CARTELA model
   */
  interface NUMEROS_CARTELAFieldRefs {
    readonly id_numero_cartela: FieldRef<"NUMEROS_CARTELA", 'Int'>
    readonly numero: FieldRef<"NUMEROS_CARTELA", 'Int'>
    readonly id_cartela: FieldRef<"NUMEROS_CARTELA", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * NUMEROS_CARTELA findUnique
   */
  export type NUMEROS_CARTELAFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NUMEROS_CARTELA
     */
    select?: NUMEROS_CARTELASelect<ExtArgs> | null
    /**
     * Omit specific fields from the NUMEROS_CARTELA
     */
    omit?: NUMEROS_CARTELAOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NUMEROS_CARTELAInclude<ExtArgs> | null
    /**
     * Filter, which NUMEROS_CARTELA to fetch.
     */
    where: NUMEROS_CARTELAWhereUniqueInput
  }

  /**
   * NUMEROS_CARTELA findUniqueOrThrow
   */
  export type NUMEROS_CARTELAFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NUMEROS_CARTELA
     */
    select?: NUMEROS_CARTELASelect<ExtArgs> | null
    /**
     * Omit specific fields from the NUMEROS_CARTELA
     */
    omit?: NUMEROS_CARTELAOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NUMEROS_CARTELAInclude<ExtArgs> | null
    /**
     * Filter, which NUMEROS_CARTELA to fetch.
     */
    where: NUMEROS_CARTELAWhereUniqueInput
  }

  /**
   * NUMEROS_CARTELA findFirst
   */
  export type NUMEROS_CARTELAFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NUMEROS_CARTELA
     */
    select?: NUMEROS_CARTELASelect<ExtArgs> | null
    /**
     * Omit specific fields from the NUMEROS_CARTELA
     */
    omit?: NUMEROS_CARTELAOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NUMEROS_CARTELAInclude<ExtArgs> | null
    /**
     * Filter, which NUMEROS_CARTELA to fetch.
     */
    where?: NUMEROS_CARTELAWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NUMEROS_CARTELAS to fetch.
     */
    orderBy?: NUMEROS_CARTELAOrderByWithRelationInput | NUMEROS_CARTELAOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NUMEROS_CARTELAS.
     */
    cursor?: NUMEROS_CARTELAWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NUMEROS_CARTELAS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NUMEROS_CARTELAS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NUMEROS_CARTELAS.
     */
    distinct?: NUMEROS_CARTELAScalarFieldEnum | NUMEROS_CARTELAScalarFieldEnum[]
  }

  /**
   * NUMEROS_CARTELA findFirstOrThrow
   */
  export type NUMEROS_CARTELAFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NUMEROS_CARTELA
     */
    select?: NUMEROS_CARTELASelect<ExtArgs> | null
    /**
     * Omit specific fields from the NUMEROS_CARTELA
     */
    omit?: NUMEROS_CARTELAOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NUMEROS_CARTELAInclude<ExtArgs> | null
    /**
     * Filter, which NUMEROS_CARTELA to fetch.
     */
    where?: NUMEROS_CARTELAWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NUMEROS_CARTELAS to fetch.
     */
    orderBy?: NUMEROS_CARTELAOrderByWithRelationInput | NUMEROS_CARTELAOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NUMEROS_CARTELAS.
     */
    cursor?: NUMEROS_CARTELAWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NUMEROS_CARTELAS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NUMEROS_CARTELAS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NUMEROS_CARTELAS.
     */
    distinct?: NUMEROS_CARTELAScalarFieldEnum | NUMEROS_CARTELAScalarFieldEnum[]
  }

  /**
   * NUMEROS_CARTELA findMany
   */
  export type NUMEROS_CARTELAFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NUMEROS_CARTELA
     */
    select?: NUMEROS_CARTELASelect<ExtArgs> | null
    /**
     * Omit specific fields from the NUMEROS_CARTELA
     */
    omit?: NUMEROS_CARTELAOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NUMEROS_CARTELAInclude<ExtArgs> | null
    /**
     * Filter, which NUMEROS_CARTELAS to fetch.
     */
    where?: NUMEROS_CARTELAWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NUMEROS_CARTELAS to fetch.
     */
    orderBy?: NUMEROS_CARTELAOrderByWithRelationInput | NUMEROS_CARTELAOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NUMEROS_CARTELAS.
     */
    cursor?: NUMEROS_CARTELAWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NUMEROS_CARTELAS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NUMEROS_CARTELAS.
     */
    skip?: number
    distinct?: NUMEROS_CARTELAScalarFieldEnum | NUMEROS_CARTELAScalarFieldEnum[]
  }

  /**
   * NUMEROS_CARTELA create
   */
  export type NUMEROS_CARTELACreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NUMEROS_CARTELA
     */
    select?: NUMEROS_CARTELASelect<ExtArgs> | null
    /**
     * Omit specific fields from the NUMEROS_CARTELA
     */
    omit?: NUMEROS_CARTELAOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NUMEROS_CARTELAInclude<ExtArgs> | null
    /**
     * The data needed to create a NUMEROS_CARTELA.
     */
    data: XOR<NUMEROS_CARTELACreateInput, NUMEROS_CARTELAUncheckedCreateInput>
  }

  /**
   * NUMEROS_CARTELA createMany
   */
  export type NUMEROS_CARTELACreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NUMEROS_CARTELAS.
     */
    data: NUMEROS_CARTELACreateManyInput | NUMEROS_CARTELACreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NUMEROS_CARTELA update
   */
  export type NUMEROS_CARTELAUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NUMEROS_CARTELA
     */
    select?: NUMEROS_CARTELASelect<ExtArgs> | null
    /**
     * Omit specific fields from the NUMEROS_CARTELA
     */
    omit?: NUMEROS_CARTELAOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NUMEROS_CARTELAInclude<ExtArgs> | null
    /**
     * The data needed to update a NUMEROS_CARTELA.
     */
    data: XOR<NUMEROS_CARTELAUpdateInput, NUMEROS_CARTELAUncheckedUpdateInput>
    /**
     * Choose, which NUMEROS_CARTELA to update.
     */
    where: NUMEROS_CARTELAWhereUniqueInput
  }

  /**
   * NUMEROS_CARTELA updateMany
   */
  export type NUMEROS_CARTELAUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NUMEROS_CARTELAS.
     */
    data: XOR<NUMEROS_CARTELAUpdateManyMutationInput, NUMEROS_CARTELAUncheckedUpdateManyInput>
    /**
     * Filter which NUMEROS_CARTELAS to update
     */
    where?: NUMEROS_CARTELAWhereInput
    /**
     * Limit how many NUMEROS_CARTELAS to update.
     */
    limit?: number
  }

  /**
   * NUMEROS_CARTELA upsert
   */
  export type NUMEROS_CARTELAUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NUMEROS_CARTELA
     */
    select?: NUMEROS_CARTELASelect<ExtArgs> | null
    /**
     * Omit specific fields from the NUMEROS_CARTELA
     */
    omit?: NUMEROS_CARTELAOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NUMEROS_CARTELAInclude<ExtArgs> | null
    /**
     * The filter to search for the NUMEROS_CARTELA to update in case it exists.
     */
    where: NUMEROS_CARTELAWhereUniqueInput
    /**
     * In case the NUMEROS_CARTELA found by the `where` argument doesn't exist, create a new NUMEROS_CARTELA with this data.
     */
    create: XOR<NUMEROS_CARTELACreateInput, NUMEROS_CARTELAUncheckedCreateInput>
    /**
     * In case the NUMEROS_CARTELA was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NUMEROS_CARTELAUpdateInput, NUMEROS_CARTELAUncheckedUpdateInput>
  }

  /**
   * NUMEROS_CARTELA delete
   */
  export type NUMEROS_CARTELADeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NUMEROS_CARTELA
     */
    select?: NUMEROS_CARTELASelect<ExtArgs> | null
    /**
     * Omit specific fields from the NUMEROS_CARTELA
     */
    omit?: NUMEROS_CARTELAOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NUMEROS_CARTELAInclude<ExtArgs> | null
    /**
     * Filter which NUMEROS_CARTELA to delete.
     */
    where: NUMEROS_CARTELAWhereUniqueInput
  }

  /**
   * NUMEROS_CARTELA deleteMany
   */
  export type NUMEROS_CARTELADeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NUMEROS_CARTELAS to delete
     */
    where?: NUMEROS_CARTELAWhereInput
    /**
     * Limit how many NUMEROS_CARTELAS to delete.
     */
    limit?: number
  }

  /**
   * NUMEROS_CARTELA without action
   */
  export type NUMEROS_CARTELADefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NUMEROS_CARTELA
     */
    select?: NUMEROS_CARTELASelect<ExtArgs> | null
    /**
     * Omit specific fields from the NUMEROS_CARTELA
     */
    omit?: NUMEROS_CARTELAOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NUMEROS_CARTELAInclude<ExtArgs> | null
  }


  /**
   * Model NUMEROS_SORTEADOS
   */

  export type AggregateNUMEROS_SORTEADOS = {
    _count: NUMEROS_SORTEADOSCountAggregateOutputType | null
    _avg: NUMEROS_SORTEADOSAvgAggregateOutputType | null
    _sum: NUMEROS_SORTEADOSSumAggregateOutputType | null
    _min: NUMEROS_SORTEADOSMinAggregateOutputType | null
    _max: NUMEROS_SORTEADOSMaxAggregateOutputType | null
  }

  export type NUMEROS_SORTEADOSAvgAggregateOutputType = {
    id_numero_sorteado: number | null
    numero: number | null
    ordem_sorteio: number | null
    id_jogo: number | null
  }

  export type NUMEROS_SORTEADOSSumAggregateOutputType = {
    id_numero_sorteado: number | null
    numero: number | null
    ordem_sorteio: number | null
    id_jogo: number | null
  }

  export type NUMEROS_SORTEADOSMinAggregateOutputType = {
    id_numero_sorteado: number | null
    numero: number | null
    ordem_sorteio: number | null
    id_jogo: number | null
  }

  export type NUMEROS_SORTEADOSMaxAggregateOutputType = {
    id_numero_sorteado: number | null
    numero: number | null
    ordem_sorteio: number | null
    id_jogo: number | null
  }

  export type NUMEROS_SORTEADOSCountAggregateOutputType = {
    id_numero_sorteado: number
    numero: number
    ordem_sorteio: number
    id_jogo: number
    _all: number
  }


  export type NUMEROS_SORTEADOSAvgAggregateInputType = {
    id_numero_sorteado?: true
    numero?: true
    ordem_sorteio?: true
    id_jogo?: true
  }

  export type NUMEROS_SORTEADOSSumAggregateInputType = {
    id_numero_sorteado?: true
    numero?: true
    ordem_sorteio?: true
    id_jogo?: true
  }

  export type NUMEROS_SORTEADOSMinAggregateInputType = {
    id_numero_sorteado?: true
    numero?: true
    ordem_sorteio?: true
    id_jogo?: true
  }

  export type NUMEROS_SORTEADOSMaxAggregateInputType = {
    id_numero_sorteado?: true
    numero?: true
    ordem_sorteio?: true
    id_jogo?: true
  }

  export type NUMEROS_SORTEADOSCountAggregateInputType = {
    id_numero_sorteado?: true
    numero?: true
    ordem_sorteio?: true
    id_jogo?: true
    _all?: true
  }

  export type NUMEROS_SORTEADOSAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NUMEROS_SORTEADOS to aggregate.
     */
    where?: NUMEROS_SORTEADOSWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NUMEROS_SORTEADOS to fetch.
     */
    orderBy?: NUMEROS_SORTEADOSOrderByWithRelationInput | NUMEROS_SORTEADOSOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NUMEROS_SORTEADOSWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NUMEROS_SORTEADOS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NUMEROS_SORTEADOS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NUMEROS_SORTEADOS
    **/
    _count?: true | NUMEROS_SORTEADOSCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NUMEROS_SORTEADOSAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NUMEROS_SORTEADOSSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NUMEROS_SORTEADOSMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NUMEROS_SORTEADOSMaxAggregateInputType
  }

  export type GetNUMEROS_SORTEADOSAggregateType<T extends NUMEROS_SORTEADOSAggregateArgs> = {
        [P in keyof T & keyof AggregateNUMEROS_SORTEADOS]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNUMEROS_SORTEADOS[P]>
      : GetScalarType<T[P], AggregateNUMEROS_SORTEADOS[P]>
  }




  export type NUMEROS_SORTEADOSGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NUMEROS_SORTEADOSWhereInput
    orderBy?: NUMEROS_SORTEADOSOrderByWithAggregationInput | NUMEROS_SORTEADOSOrderByWithAggregationInput[]
    by: NUMEROS_SORTEADOSScalarFieldEnum[] | NUMEROS_SORTEADOSScalarFieldEnum
    having?: NUMEROS_SORTEADOSScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NUMEROS_SORTEADOSCountAggregateInputType | true
    _avg?: NUMEROS_SORTEADOSAvgAggregateInputType
    _sum?: NUMEROS_SORTEADOSSumAggregateInputType
    _min?: NUMEROS_SORTEADOSMinAggregateInputType
    _max?: NUMEROS_SORTEADOSMaxAggregateInputType
  }

  export type NUMEROS_SORTEADOSGroupByOutputType = {
    id_numero_sorteado: number
    numero: number
    ordem_sorteio: number
    id_jogo: number
    _count: NUMEROS_SORTEADOSCountAggregateOutputType | null
    _avg: NUMEROS_SORTEADOSAvgAggregateOutputType | null
    _sum: NUMEROS_SORTEADOSSumAggregateOutputType | null
    _min: NUMEROS_SORTEADOSMinAggregateOutputType | null
    _max: NUMEROS_SORTEADOSMaxAggregateOutputType | null
  }

  type GetNUMEROS_SORTEADOSGroupByPayload<T extends NUMEROS_SORTEADOSGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NUMEROS_SORTEADOSGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NUMEROS_SORTEADOSGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NUMEROS_SORTEADOSGroupByOutputType[P]>
            : GetScalarType<T[P], NUMEROS_SORTEADOSGroupByOutputType[P]>
        }
      >
    >


  export type NUMEROS_SORTEADOSSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_numero_sorteado?: boolean
    numero?: boolean
    ordem_sorteio?: boolean
    id_jogo?: boolean
    JOGO?: boolean | JOGODefaultArgs<ExtArgs>
  }, ExtArgs["result"]["nUMEROS_SORTEADOS"]>



  export type NUMEROS_SORTEADOSSelectScalar = {
    id_numero_sorteado?: boolean
    numero?: boolean
    ordem_sorteio?: boolean
    id_jogo?: boolean
  }

  export type NUMEROS_SORTEADOSOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id_numero_sorteado" | "numero" | "ordem_sorteio" | "id_jogo", ExtArgs["result"]["nUMEROS_SORTEADOS"]>
  export type NUMEROS_SORTEADOSInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    JOGO?: boolean | JOGODefaultArgs<ExtArgs>
  }

  export type $NUMEROS_SORTEADOSPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NUMEROS_SORTEADOS"
    objects: {
      JOGO: Prisma.$JOGOPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id_numero_sorteado: number
      numero: number
      ordem_sorteio: number
      id_jogo: number
    }, ExtArgs["result"]["nUMEROS_SORTEADOS"]>
    composites: {}
  }

  type NUMEROS_SORTEADOSGetPayload<S extends boolean | null | undefined | NUMEROS_SORTEADOSDefaultArgs> = $Result.GetResult<Prisma.$NUMEROS_SORTEADOSPayload, S>

  type NUMEROS_SORTEADOSCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NUMEROS_SORTEADOSFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NUMEROS_SORTEADOSCountAggregateInputType | true
    }

  export interface NUMEROS_SORTEADOSDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NUMEROS_SORTEADOS'], meta: { name: 'NUMEROS_SORTEADOS' } }
    /**
     * Find zero or one NUMEROS_SORTEADOS that matches the filter.
     * @param {NUMEROS_SORTEADOSFindUniqueArgs} args - Arguments to find a NUMEROS_SORTEADOS
     * @example
     * // Get one NUMEROS_SORTEADOS
     * const nUMEROS_SORTEADOS = await prisma.nUMEROS_SORTEADOS.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NUMEROS_SORTEADOSFindUniqueArgs>(args: SelectSubset<T, NUMEROS_SORTEADOSFindUniqueArgs<ExtArgs>>): Prisma__NUMEROS_SORTEADOSClient<$Result.GetResult<Prisma.$NUMEROS_SORTEADOSPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one NUMEROS_SORTEADOS that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NUMEROS_SORTEADOSFindUniqueOrThrowArgs} args - Arguments to find a NUMEROS_SORTEADOS
     * @example
     * // Get one NUMEROS_SORTEADOS
     * const nUMEROS_SORTEADOS = await prisma.nUMEROS_SORTEADOS.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NUMEROS_SORTEADOSFindUniqueOrThrowArgs>(args: SelectSubset<T, NUMEROS_SORTEADOSFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NUMEROS_SORTEADOSClient<$Result.GetResult<Prisma.$NUMEROS_SORTEADOSPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NUMEROS_SORTEADOS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NUMEROS_SORTEADOSFindFirstArgs} args - Arguments to find a NUMEROS_SORTEADOS
     * @example
     * // Get one NUMEROS_SORTEADOS
     * const nUMEROS_SORTEADOS = await prisma.nUMEROS_SORTEADOS.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NUMEROS_SORTEADOSFindFirstArgs>(args?: SelectSubset<T, NUMEROS_SORTEADOSFindFirstArgs<ExtArgs>>): Prisma__NUMEROS_SORTEADOSClient<$Result.GetResult<Prisma.$NUMEROS_SORTEADOSPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NUMEROS_SORTEADOS that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NUMEROS_SORTEADOSFindFirstOrThrowArgs} args - Arguments to find a NUMEROS_SORTEADOS
     * @example
     * // Get one NUMEROS_SORTEADOS
     * const nUMEROS_SORTEADOS = await prisma.nUMEROS_SORTEADOS.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NUMEROS_SORTEADOSFindFirstOrThrowArgs>(args?: SelectSubset<T, NUMEROS_SORTEADOSFindFirstOrThrowArgs<ExtArgs>>): Prisma__NUMEROS_SORTEADOSClient<$Result.GetResult<Prisma.$NUMEROS_SORTEADOSPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more NUMEROS_SORTEADOS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NUMEROS_SORTEADOSFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NUMEROS_SORTEADOS
     * const nUMEROS_SORTEADOS = await prisma.nUMEROS_SORTEADOS.findMany()
     * 
     * // Get first 10 NUMEROS_SORTEADOS
     * const nUMEROS_SORTEADOS = await prisma.nUMEROS_SORTEADOS.findMany({ take: 10 })
     * 
     * // Only select the `id_numero_sorteado`
     * const nUMEROS_SORTEADOSWithId_numero_sorteadoOnly = await prisma.nUMEROS_SORTEADOS.findMany({ select: { id_numero_sorteado: true } })
     * 
     */
    findMany<T extends NUMEROS_SORTEADOSFindManyArgs>(args?: SelectSubset<T, NUMEROS_SORTEADOSFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NUMEROS_SORTEADOSPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a NUMEROS_SORTEADOS.
     * @param {NUMEROS_SORTEADOSCreateArgs} args - Arguments to create a NUMEROS_SORTEADOS.
     * @example
     * // Create one NUMEROS_SORTEADOS
     * const NUMEROS_SORTEADOS = await prisma.nUMEROS_SORTEADOS.create({
     *   data: {
     *     // ... data to create a NUMEROS_SORTEADOS
     *   }
     * })
     * 
     */
    create<T extends NUMEROS_SORTEADOSCreateArgs>(args: SelectSubset<T, NUMEROS_SORTEADOSCreateArgs<ExtArgs>>): Prisma__NUMEROS_SORTEADOSClient<$Result.GetResult<Prisma.$NUMEROS_SORTEADOSPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many NUMEROS_SORTEADOS.
     * @param {NUMEROS_SORTEADOSCreateManyArgs} args - Arguments to create many NUMEROS_SORTEADOS.
     * @example
     * // Create many NUMEROS_SORTEADOS
     * const nUMEROS_SORTEADOS = await prisma.nUMEROS_SORTEADOS.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NUMEROS_SORTEADOSCreateManyArgs>(args?: SelectSubset<T, NUMEROS_SORTEADOSCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a NUMEROS_SORTEADOS.
     * @param {NUMEROS_SORTEADOSDeleteArgs} args - Arguments to delete one NUMEROS_SORTEADOS.
     * @example
     * // Delete one NUMEROS_SORTEADOS
     * const NUMEROS_SORTEADOS = await prisma.nUMEROS_SORTEADOS.delete({
     *   where: {
     *     // ... filter to delete one NUMEROS_SORTEADOS
     *   }
     * })
     * 
     */
    delete<T extends NUMEROS_SORTEADOSDeleteArgs>(args: SelectSubset<T, NUMEROS_SORTEADOSDeleteArgs<ExtArgs>>): Prisma__NUMEROS_SORTEADOSClient<$Result.GetResult<Prisma.$NUMEROS_SORTEADOSPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one NUMEROS_SORTEADOS.
     * @param {NUMEROS_SORTEADOSUpdateArgs} args - Arguments to update one NUMEROS_SORTEADOS.
     * @example
     * // Update one NUMEROS_SORTEADOS
     * const nUMEROS_SORTEADOS = await prisma.nUMEROS_SORTEADOS.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NUMEROS_SORTEADOSUpdateArgs>(args: SelectSubset<T, NUMEROS_SORTEADOSUpdateArgs<ExtArgs>>): Prisma__NUMEROS_SORTEADOSClient<$Result.GetResult<Prisma.$NUMEROS_SORTEADOSPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more NUMEROS_SORTEADOS.
     * @param {NUMEROS_SORTEADOSDeleteManyArgs} args - Arguments to filter NUMEROS_SORTEADOS to delete.
     * @example
     * // Delete a few NUMEROS_SORTEADOS
     * const { count } = await prisma.nUMEROS_SORTEADOS.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NUMEROS_SORTEADOSDeleteManyArgs>(args?: SelectSubset<T, NUMEROS_SORTEADOSDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NUMEROS_SORTEADOS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NUMEROS_SORTEADOSUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NUMEROS_SORTEADOS
     * const nUMEROS_SORTEADOS = await prisma.nUMEROS_SORTEADOS.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NUMEROS_SORTEADOSUpdateManyArgs>(args: SelectSubset<T, NUMEROS_SORTEADOSUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one NUMEROS_SORTEADOS.
     * @param {NUMEROS_SORTEADOSUpsertArgs} args - Arguments to update or create a NUMEROS_SORTEADOS.
     * @example
     * // Update or create a NUMEROS_SORTEADOS
     * const nUMEROS_SORTEADOS = await prisma.nUMEROS_SORTEADOS.upsert({
     *   create: {
     *     // ... data to create a NUMEROS_SORTEADOS
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NUMEROS_SORTEADOS we want to update
     *   }
     * })
     */
    upsert<T extends NUMEROS_SORTEADOSUpsertArgs>(args: SelectSubset<T, NUMEROS_SORTEADOSUpsertArgs<ExtArgs>>): Prisma__NUMEROS_SORTEADOSClient<$Result.GetResult<Prisma.$NUMEROS_SORTEADOSPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of NUMEROS_SORTEADOS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NUMEROS_SORTEADOSCountArgs} args - Arguments to filter NUMEROS_SORTEADOS to count.
     * @example
     * // Count the number of NUMEROS_SORTEADOS
     * const count = await prisma.nUMEROS_SORTEADOS.count({
     *   where: {
     *     // ... the filter for the NUMEROS_SORTEADOS we want to count
     *   }
     * })
    **/
    count<T extends NUMEROS_SORTEADOSCountArgs>(
      args?: Subset<T, NUMEROS_SORTEADOSCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NUMEROS_SORTEADOSCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NUMEROS_SORTEADOS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NUMEROS_SORTEADOSAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NUMEROS_SORTEADOSAggregateArgs>(args: Subset<T, NUMEROS_SORTEADOSAggregateArgs>): Prisma.PrismaPromise<GetNUMEROS_SORTEADOSAggregateType<T>>

    /**
     * Group by NUMEROS_SORTEADOS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NUMEROS_SORTEADOSGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NUMEROS_SORTEADOSGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NUMEROS_SORTEADOSGroupByArgs['orderBy'] }
        : { orderBy?: NUMEROS_SORTEADOSGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NUMEROS_SORTEADOSGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNUMEROS_SORTEADOSGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NUMEROS_SORTEADOS model
   */
  readonly fields: NUMEROS_SORTEADOSFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NUMEROS_SORTEADOS.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NUMEROS_SORTEADOSClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    JOGO<T extends JOGODefaultArgs<ExtArgs> = {}>(args?: Subset<T, JOGODefaultArgs<ExtArgs>>): Prisma__JOGOClient<$Result.GetResult<Prisma.$JOGOPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the NUMEROS_SORTEADOS model
   */
  interface NUMEROS_SORTEADOSFieldRefs {
    readonly id_numero_sorteado: FieldRef<"NUMEROS_SORTEADOS", 'Int'>
    readonly numero: FieldRef<"NUMEROS_SORTEADOS", 'Int'>
    readonly ordem_sorteio: FieldRef<"NUMEROS_SORTEADOS", 'Int'>
    readonly id_jogo: FieldRef<"NUMEROS_SORTEADOS", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * NUMEROS_SORTEADOS findUnique
   */
  export type NUMEROS_SORTEADOSFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NUMEROS_SORTEADOS
     */
    select?: NUMEROS_SORTEADOSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NUMEROS_SORTEADOS
     */
    omit?: NUMEROS_SORTEADOSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NUMEROS_SORTEADOSInclude<ExtArgs> | null
    /**
     * Filter, which NUMEROS_SORTEADOS to fetch.
     */
    where: NUMEROS_SORTEADOSWhereUniqueInput
  }

  /**
   * NUMEROS_SORTEADOS findUniqueOrThrow
   */
  export type NUMEROS_SORTEADOSFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NUMEROS_SORTEADOS
     */
    select?: NUMEROS_SORTEADOSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NUMEROS_SORTEADOS
     */
    omit?: NUMEROS_SORTEADOSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NUMEROS_SORTEADOSInclude<ExtArgs> | null
    /**
     * Filter, which NUMEROS_SORTEADOS to fetch.
     */
    where: NUMEROS_SORTEADOSWhereUniqueInput
  }

  /**
   * NUMEROS_SORTEADOS findFirst
   */
  export type NUMEROS_SORTEADOSFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NUMEROS_SORTEADOS
     */
    select?: NUMEROS_SORTEADOSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NUMEROS_SORTEADOS
     */
    omit?: NUMEROS_SORTEADOSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NUMEROS_SORTEADOSInclude<ExtArgs> | null
    /**
     * Filter, which NUMEROS_SORTEADOS to fetch.
     */
    where?: NUMEROS_SORTEADOSWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NUMEROS_SORTEADOS to fetch.
     */
    orderBy?: NUMEROS_SORTEADOSOrderByWithRelationInput | NUMEROS_SORTEADOSOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NUMEROS_SORTEADOS.
     */
    cursor?: NUMEROS_SORTEADOSWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NUMEROS_SORTEADOS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NUMEROS_SORTEADOS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NUMEROS_SORTEADOS.
     */
    distinct?: NUMEROS_SORTEADOSScalarFieldEnum | NUMEROS_SORTEADOSScalarFieldEnum[]
  }

  /**
   * NUMEROS_SORTEADOS findFirstOrThrow
   */
  export type NUMEROS_SORTEADOSFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NUMEROS_SORTEADOS
     */
    select?: NUMEROS_SORTEADOSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NUMEROS_SORTEADOS
     */
    omit?: NUMEROS_SORTEADOSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NUMEROS_SORTEADOSInclude<ExtArgs> | null
    /**
     * Filter, which NUMEROS_SORTEADOS to fetch.
     */
    where?: NUMEROS_SORTEADOSWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NUMEROS_SORTEADOS to fetch.
     */
    orderBy?: NUMEROS_SORTEADOSOrderByWithRelationInput | NUMEROS_SORTEADOSOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NUMEROS_SORTEADOS.
     */
    cursor?: NUMEROS_SORTEADOSWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NUMEROS_SORTEADOS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NUMEROS_SORTEADOS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NUMEROS_SORTEADOS.
     */
    distinct?: NUMEROS_SORTEADOSScalarFieldEnum | NUMEROS_SORTEADOSScalarFieldEnum[]
  }

  /**
   * NUMEROS_SORTEADOS findMany
   */
  export type NUMEROS_SORTEADOSFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NUMEROS_SORTEADOS
     */
    select?: NUMEROS_SORTEADOSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NUMEROS_SORTEADOS
     */
    omit?: NUMEROS_SORTEADOSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NUMEROS_SORTEADOSInclude<ExtArgs> | null
    /**
     * Filter, which NUMEROS_SORTEADOS to fetch.
     */
    where?: NUMEROS_SORTEADOSWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NUMEROS_SORTEADOS to fetch.
     */
    orderBy?: NUMEROS_SORTEADOSOrderByWithRelationInput | NUMEROS_SORTEADOSOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NUMEROS_SORTEADOS.
     */
    cursor?: NUMEROS_SORTEADOSWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NUMEROS_SORTEADOS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NUMEROS_SORTEADOS.
     */
    skip?: number
    distinct?: NUMEROS_SORTEADOSScalarFieldEnum | NUMEROS_SORTEADOSScalarFieldEnum[]
  }

  /**
   * NUMEROS_SORTEADOS create
   */
  export type NUMEROS_SORTEADOSCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NUMEROS_SORTEADOS
     */
    select?: NUMEROS_SORTEADOSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NUMEROS_SORTEADOS
     */
    omit?: NUMEROS_SORTEADOSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NUMEROS_SORTEADOSInclude<ExtArgs> | null
    /**
     * The data needed to create a NUMEROS_SORTEADOS.
     */
    data: XOR<NUMEROS_SORTEADOSCreateInput, NUMEROS_SORTEADOSUncheckedCreateInput>
  }

  /**
   * NUMEROS_SORTEADOS createMany
   */
  export type NUMEROS_SORTEADOSCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NUMEROS_SORTEADOS.
     */
    data: NUMEROS_SORTEADOSCreateManyInput | NUMEROS_SORTEADOSCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NUMEROS_SORTEADOS update
   */
  export type NUMEROS_SORTEADOSUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NUMEROS_SORTEADOS
     */
    select?: NUMEROS_SORTEADOSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NUMEROS_SORTEADOS
     */
    omit?: NUMEROS_SORTEADOSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NUMEROS_SORTEADOSInclude<ExtArgs> | null
    /**
     * The data needed to update a NUMEROS_SORTEADOS.
     */
    data: XOR<NUMEROS_SORTEADOSUpdateInput, NUMEROS_SORTEADOSUncheckedUpdateInput>
    /**
     * Choose, which NUMEROS_SORTEADOS to update.
     */
    where: NUMEROS_SORTEADOSWhereUniqueInput
  }

  /**
   * NUMEROS_SORTEADOS updateMany
   */
  export type NUMEROS_SORTEADOSUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NUMEROS_SORTEADOS.
     */
    data: XOR<NUMEROS_SORTEADOSUpdateManyMutationInput, NUMEROS_SORTEADOSUncheckedUpdateManyInput>
    /**
     * Filter which NUMEROS_SORTEADOS to update
     */
    where?: NUMEROS_SORTEADOSWhereInput
    /**
     * Limit how many NUMEROS_SORTEADOS to update.
     */
    limit?: number
  }

  /**
   * NUMEROS_SORTEADOS upsert
   */
  export type NUMEROS_SORTEADOSUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NUMEROS_SORTEADOS
     */
    select?: NUMEROS_SORTEADOSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NUMEROS_SORTEADOS
     */
    omit?: NUMEROS_SORTEADOSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NUMEROS_SORTEADOSInclude<ExtArgs> | null
    /**
     * The filter to search for the NUMEROS_SORTEADOS to update in case it exists.
     */
    where: NUMEROS_SORTEADOSWhereUniqueInput
    /**
     * In case the NUMEROS_SORTEADOS found by the `where` argument doesn't exist, create a new NUMEROS_SORTEADOS with this data.
     */
    create: XOR<NUMEROS_SORTEADOSCreateInput, NUMEROS_SORTEADOSUncheckedCreateInput>
    /**
     * In case the NUMEROS_SORTEADOS was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NUMEROS_SORTEADOSUpdateInput, NUMEROS_SORTEADOSUncheckedUpdateInput>
  }

  /**
   * NUMEROS_SORTEADOS delete
   */
  export type NUMEROS_SORTEADOSDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NUMEROS_SORTEADOS
     */
    select?: NUMEROS_SORTEADOSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NUMEROS_SORTEADOS
     */
    omit?: NUMEROS_SORTEADOSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NUMEROS_SORTEADOSInclude<ExtArgs> | null
    /**
     * Filter which NUMEROS_SORTEADOS to delete.
     */
    where: NUMEROS_SORTEADOSWhereUniqueInput
  }

  /**
   * NUMEROS_SORTEADOS deleteMany
   */
  export type NUMEROS_SORTEADOSDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NUMEROS_SORTEADOS to delete
     */
    where?: NUMEROS_SORTEADOSWhereInput
    /**
     * Limit how many NUMEROS_SORTEADOS to delete.
     */
    limit?: number
  }

  /**
   * NUMEROS_SORTEADOS without action
   */
  export type NUMEROS_SORTEADOSDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NUMEROS_SORTEADOS
     */
    select?: NUMEROS_SORTEADOSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NUMEROS_SORTEADOS
     */
    omit?: NUMEROS_SORTEADOSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NUMEROS_SORTEADOSInclude<ExtArgs> | null
  }


  /**
   * Model PREMIOS
   */

  export type AggregatePREMIOS = {
    _count: PREMIOSCountAggregateOutputType | null
    _avg: PREMIOSAvgAggregateOutputType | null
    _sum: PREMIOSSumAggregateOutputType | null
    _min: PREMIOSMinAggregateOutputType | null
    _max: PREMIOSMaxAggregateOutputType | null
  }

  export type PREMIOSAvgAggregateOutputType = {
    id_premio: number | null
    valor: Decimal | null
    id_usuario: number | null
    id_jogo: number | null
  }

  export type PREMIOSSumAggregateOutputType = {
    id_premio: number | null
    valor: Decimal | null
    id_usuario: number | null
    id_jogo: number | null
  }

  export type PREMIOSMinAggregateOutputType = {
    id_premio: number | null
    descricao: string | null
    valor: Decimal | null
    id_usuario: number | null
    id_jogo: number | null
  }

  export type PREMIOSMaxAggregateOutputType = {
    id_premio: number | null
    descricao: string | null
    valor: Decimal | null
    id_usuario: number | null
    id_jogo: number | null
  }

  export type PREMIOSCountAggregateOutputType = {
    id_premio: number
    descricao: number
    valor: number
    id_usuario: number
    id_jogo: number
    _all: number
  }


  export type PREMIOSAvgAggregateInputType = {
    id_premio?: true
    valor?: true
    id_usuario?: true
    id_jogo?: true
  }

  export type PREMIOSSumAggregateInputType = {
    id_premio?: true
    valor?: true
    id_usuario?: true
    id_jogo?: true
  }

  export type PREMIOSMinAggregateInputType = {
    id_premio?: true
    descricao?: true
    valor?: true
    id_usuario?: true
    id_jogo?: true
  }

  export type PREMIOSMaxAggregateInputType = {
    id_premio?: true
    descricao?: true
    valor?: true
    id_usuario?: true
    id_jogo?: true
  }

  export type PREMIOSCountAggregateInputType = {
    id_premio?: true
    descricao?: true
    valor?: true
    id_usuario?: true
    id_jogo?: true
    _all?: true
  }

  export type PREMIOSAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PREMIOS to aggregate.
     */
    where?: PREMIOSWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PREMIOS to fetch.
     */
    orderBy?: PREMIOSOrderByWithRelationInput | PREMIOSOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PREMIOSWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PREMIOS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PREMIOS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PREMIOS
    **/
    _count?: true | PREMIOSCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PREMIOSAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PREMIOSSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PREMIOSMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PREMIOSMaxAggregateInputType
  }

  export type GetPREMIOSAggregateType<T extends PREMIOSAggregateArgs> = {
        [P in keyof T & keyof AggregatePREMIOS]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePREMIOS[P]>
      : GetScalarType<T[P], AggregatePREMIOS[P]>
  }




  export type PREMIOSGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PREMIOSWhereInput
    orderBy?: PREMIOSOrderByWithAggregationInput | PREMIOSOrderByWithAggregationInput[]
    by: PREMIOSScalarFieldEnum[] | PREMIOSScalarFieldEnum
    having?: PREMIOSScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PREMIOSCountAggregateInputType | true
    _avg?: PREMIOSAvgAggregateInputType
    _sum?: PREMIOSSumAggregateInputType
    _min?: PREMIOSMinAggregateInputType
    _max?: PREMIOSMaxAggregateInputType
  }

  export type PREMIOSGroupByOutputType = {
    id_premio: number
    descricao: string
    valor: Decimal
    id_usuario: number | null
    id_jogo: number
    _count: PREMIOSCountAggregateOutputType | null
    _avg: PREMIOSAvgAggregateOutputType | null
    _sum: PREMIOSSumAggregateOutputType | null
    _min: PREMIOSMinAggregateOutputType | null
    _max: PREMIOSMaxAggregateOutputType | null
  }

  type GetPREMIOSGroupByPayload<T extends PREMIOSGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PREMIOSGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PREMIOSGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PREMIOSGroupByOutputType[P]>
            : GetScalarType<T[P], PREMIOSGroupByOutputType[P]>
        }
      >
    >


  export type PREMIOSSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_premio?: boolean
    descricao?: boolean
    valor?: boolean
    id_usuario?: boolean
    id_jogo?: boolean
    JOGO?: boolean | JOGODefaultArgs<ExtArgs>
    USUARIO?: boolean | PREMIOS$USUARIOArgs<ExtArgs>
  }, ExtArgs["result"]["pREMIOS"]>



  export type PREMIOSSelectScalar = {
    id_premio?: boolean
    descricao?: boolean
    valor?: boolean
    id_usuario?: boolean
    id_jogo?: boolean
  }

  export type PREMIOSOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id_premio" | "descricao" | "valor" | "id_usuario" | "id_jogo", ExtArgs["result"]["pREMIOS"]>
  export type PREMIOSInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    JOGO?: boolean | JOGODefaultArgs<ExtArgs>
    USUARIO?: boolean | PREMIOS$USUARIOArgs<ExtArgs>
  }

  export type $PREMIOSPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PREMIOS"
    objects: {
      JOGO: Prisma.$JOGOPayload<ExtArgs>
      USUARIO: Prisma.$USUARIOPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id_premio: number
      descricao: string
      valor: Prisma.Decimal
      id_usuario: number | null
      id_jogo: number
    }, ExtArgs["result"]["pREMIOS"]>
    composites: {}
  }

  type PREMIOSGetPayload<S extends boolean | null | undefined | PREMIOSDefaultArgs> = $Result.GetResult<Prisma.$PREMIOSPayload, S>

  type PREMIOSCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PREMIOSFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PREMIOSCountAggregateInputType | true
    }

  export interface PREMIOSDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PREMIOS'], meta: { name: 'PREMIOS' } }
    /**
     * Find zero or one PREMIOS that matches the filter.
     * @param {PREMIOSFindUniqueArgs} args - Arguments to find a PREMIOS
     * @example
     * // Get one PREMIOS
     * const pREMIOS = await prisma.pREMIOS.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PREMIOSFindUniqueArgs>(args: SelectSubset<T, PREMIOSFindUniqueArgs<ExtArgs>>): Prisma__PREMIOSClient<$Result.GetResult<Prisma.$PREMIOSPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PREMIOS that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PREMIOSFindUniqueOrThrowArgs} args - Arguments to find a PREMIOS
     * @example
     * // Get one PREMIOS
     * const pREMIOS = await prisma.pREMIOS.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PREMIOSFindUniqueOrThrowArgs>(args: SelectSubset<T, PREMIOSFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PREMIOSClient<$Result.GetResult<Prisma.$PREMIOSPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PREMIOS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PREMIOSFindFirstArgs} args - Arguments to find a PREMIOS
     * @example
     * // Get one PREMIOS
     * const pREMIOS = await prisma.pREMIOS.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PREMIOSFindFirstArgs>(args?: SelectSubset<T, PREMIOSFindFirstArgs<ExtArgs>>): Prisma__PREMIOSClient<$Result.GetResult<Prisma.$PREMIOSPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PREMIOS that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PREMIOSFindFirstOrThrowArgs} args - Arguments to find a PREMIOS
     * @example
     * // Get one PREMIOS
     * const pREMIOS = await prisma.pREMIOS.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PREMIOSFindFirstOrThrowArgs>(args?: SelectSubset<T, PREMIOSFindFirstOrThrowArgs<ExtArgs>>): Prisma__PREMIOSClient<$Result.GetResult<Prisma.$PREMIOSPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PREMIOS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PREMIOSFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PREMIOS
     * const pREMIOS = await prisma.pREMIOS.findMany()
     * 
     * // Get first 10 PREMIOS
     * const pREMIOS = await prisma.pREMIOS.findMany({ take: 10 })
     * 
     * // Only select the `id_premio`
     * const pREMIOSWithId_premioOnly = await prisma.pREMIOS.findMany({ select: { id_premio: true } })
     * 
     */
    findMany<T extends PREMIOSFindManyArgs>(args?: SelectSubset<T, PREMIOSFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PREMIOSPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PREMIOS.
     * @param {PREMIOSCreateArgs} args - Arguments to create a PREMIOS.
     * @example
     * // Create one PREMIOS
     * const PREMIOS = await prisma.pREMIOS.create({
     *   data: {
     *     // ... data to create a PREMIOS
     *   }
     * })
     * 
     */
    create<T extends PREMIOSCreateArgs>(args: SelectSubset<T, PREMIOSCreateArgs<ExtArgs>>): Prisma__PREMIOSClient<$Result.GetResult<Prisma.$PREMIOSPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PREMIOS.
     * @param {PREMIOSCreateManyArgs} args - Arguments to create many PREMIOS.
     * @example
     * // Create many PREMIOS
     * const pREMIOS = await prisma.pREMIOS.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PREMIOSCreateManyArgs>(args?: SelectSubset<T, PREMIOSCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a PREMIOS.
     * @param {PREMIOSDeleteArgs} args - Arguments to delete one PREMIOS.
     * @example
     * // Delete one PREMIOS
     * const PREMIOS = await prisma.pREMIOS.delete({
     *   where: {
     *     // ... filter to delete one PREMIOS
     *   }
     * })
     * 
     */
    delete<T extends PREMIOSDeleteArgs>(args: SelectSubset<T, PREMIOSDeleteArgs<ExtArgs>>): Prisma__PREMIOSClient<$Result.GetResult<Prisma.$PREMIOSPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PREMIOS.
     * @param {PREMIOSUpdateArgs} args - Arguments to update one PREMIOS.
     * @example
     * // Update one PREMIOS
     * const pREMIOS = await prisma.pREMIOS.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PREMIOSUpdateArgs>(args: SelectSubset<T, PREMIOSUpdateArgs<ExtArgs>>): Prisma__PREMIOSClient<$Result.GetResult<Prisma.$PREMIOSPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PREMIOS.
     * @param {PREMIOSDeleteManyArgs} args - Arguments to filter PREMIOS to delete.
     * @example
     * // Delete a few PREMIOS
     * const { count } = await prisma.pREMIOS.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PREMIOSDeleteManyArgs>(args?: SelectSubset<T, PREMIOSDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PREMIOS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PREMIOSUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PREMIOS
     * const pREMIOS = await prisma.pREMIOS.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PREMIOSUpdateManyArgs>(args: SelectSubset<T, PREMIOSUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PREMIOS.
     * @param {PREMIOSUpsertArgs} args - Arguments to update or create a PREMIOS.
     * @example
     * // Update or create a PREMIOS
     * const pREMIOS = await prisma.pREMIOS.upsert({
     *   create: {
     *     // ... data to create a PREMIOS
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PREMIOS we want to update
     *   }
     * })
     */
    upsert<T extends PREMIOSUpsertArgs>(args: SelectSubset<T, PREMIOSUpsertArgs<ExtArgs>>): Prisma__PREMIOSClient<$Result.GetResult<Prisma.$PREMIOSPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PREMIOS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PREMIOSCountArgs} args - Arguments to filter PREMIOS to count.
     * @example
     * // Count the number of PREMIOS
     * const count = await prisma.pREMIOS.count({
     *   where: {
     *     // ... the filter for the PREMIOS we want to count
     *   }
     * })
    **/
    count<T extends PREMIOSCountArgs>(
      args?: Subset<T, PREMIOSCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PREMIOSCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PREMIOS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PREMIOSAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PREMIOSAggregateArgs>(args: Subset<T, PREMIOSAggregateArgs>): Prisma.PrismaPromise<GetPREMIOSAggregateType<T>>

    /**
     * Group by PREMIOS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PREMIOSGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PREMIOSGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PREMIOSGroupByArgs['orderBy'] }
        : { orderBy?: PREMIOSGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PREMIOSGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPREMIOSGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PREMIOS model
   */
  readonly fields: PREMIOSFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PREMIOS.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PREMIOSClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    JOGO<T extends JOGODefaultArgs<ExtArgs> = {}>(args?: Subset<T, JOGODefaultArgs<ExtArgs>>): Prisma__JOGOClient<$Result.GetResult<Prisma.$JOGOPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    USUARIO<T extends PREMIOS$USUARIOArgs<ExtArgs> = {}>(args?: Subset<T, PREMIOS$USUARIOArgs<ExtArgs>>): Prisma__USUARIOClient<$Result.GetResult<Prisma.$USUARIOPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PREMIOS model
   */
  interface PREMIOSFieldRefs {
    readonly id_premio: FieldRef<"PREMIOS", 'Int'>
    readonly descricao: FieldRef<"PREMIOS", 'String'>
    readonly valor: FieldRef<"PREMIOS", 'Decimal'>
    readonly id_usuario: FieldRef<"PREMIOS", 'Int'>
    readonly id_jogo: FieldRef<"PREMIOS", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * PREMIOS findUnique
   */
  export type PREMIOSFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PREMIOS
     */
    select?: PREMIOSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PREMIOS
     */
    omit?: PREMIOSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PREMIOSInclude<ExtArgs> | null
    /**
     * Filter, which PREMIOS to fetch.
     */
    where: PREMIOSWhereUniqueInput
  }

  /**
   * PREMIOS findUniqueOrThrow
   */
  export type PREMIOSFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PREMIOS
     */
    select?: PREMIOSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PREMIOS
     */
    omit?: PREMIOSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PREMIOSInclude<ExtArgs> | null
    /**
     * Filter, which PREMIOS to fetch.
     */
    where: PREMIOSWhereUniqueInput
  }

  /**
   * PREMIOS findFirst
   */
  export type PREMIOSFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PREMIOS
     */
    select?: PREMIOSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PREMIOS
     */
    omit?: PREMIOSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PREMIOSInclude<ExtArgs> | null
    /**
     * Filter, which PREMIOS to fetch.
     */
    where?: PREMIOSWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PREMIOS to fetch.
     */
    orderBy?: PREMIOSOrderByWithRelationInput | PREMIOSOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PREMIOS.
     */
    cursor?: PREMIOSWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PREMIOS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PREMIOS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PREMIOS.
     */
    distinct?: PREMIOSScalarFieldEnum | PREMIOSScalarFieldEnum[]
  }

  /**
   * PREMIOS findFirstOrThrow
   */
  export type PREMIOSFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PREMIOS
     */
    select?: PREMIOSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PREMIOS
     */
    omit?: PREMIOSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PREMIOSInclude<ExtArgs> | null
    /**
     * Filter, which PREMIOS to fetch.
     */
    where?: PREMIOSWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PREMIOS to fetch.
     */
    orderBy?: PREMIOSOrderByWithRelationInput | PREMIOSOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PREMIOS.
     */
    cursor?: PREMIOSWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PREMIOS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PREMIOS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PREMIOS.
     */
    distinct?: PREMIOSScalarFieldEnum | PREMIOSScalarFieldEnum[]
  }

  /**
   * PREMIOS findMany
   */
  export type PREMIOSFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PREMIOS
     */
    select?: PREMIOSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PREMIOS
     */
    omit?: PREMIOSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PREMIOSInclude<ExtArgs> | null
    /**
     * Filter, which PREMIOS to fetch.
     */
    where?: PREMIOSWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PREMIOS to fetch.
     */
    orderBy?: PREMIOSOrderByWithRelationInput | PREMIOSOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PREMIOS.
     */
    cursor?: PREMIOSWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PREMIOS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PREMIOS.
     */
    skip?: number
    distinct?: PREMIOSScalarFieldEnum | PREMIOSScalarFieldEnum[]
  }

  /**
   * PREMIOS create
   */
  export type PREMIOSCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PREMIOS
     */
    select?: PREMIOSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PREMIOS
     */
    omit?: PREMIOSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PREMIOSInclude<ExtArgs> | null
    /**
     * The data needed to create a PREMIOS.
     */
    data: XOR<PREMIOSCreateInput, PREMIOSUncheckedCreateInput>
  }

  /**
   * PREMIOS createMany
   */
  export type PREMIOSCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PREMIOS.
     */
    data: PREMIOSCreateManyInput | PREMIOSCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PREMIOS update
   */
  export type PREMIOSUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PREMIOS
     */
    select?: PREMIOSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PREMIOS
     */
    omit?: PREMIOSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PREMIOSInclude<ExtArgs> | null
    /**
     * The data needed to update a PREMIOS.
     */
    data: XOR<PREMIOSUpdateInput, PREMIOSUncheckedUpdateInput>
    /**
     * Choose, which PREMIOS to update.
     */
    where: PREMIOSWhereUniqueInput
  }

  /**
   * PREMIOS updateMany
   */
  export type PREMIOSUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PREMIOS.
     */
    data: XOR<PREMIOSUpdateManyMutationInput, PREMIOSUncheckedUpdateManyInput>
    /**
     * Filter which PREMIOS to update
     */
    where?: PREMIOSWhereInput
    /**
     * Limit how many PREMIOS to update.
     */
    limit?: number
  }

  /**
   * PREMIOS upsert
   */
  export type PREMIOSUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PREMIOS
     */
    select?: PREMIOSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PREMIOS
     */
    omit?: PREMIOSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PREMIOSInclude<ExtArgs> | null
    /**
     * The filter to search for the PREMIOS to update in case it exists.
     */
    where: PREMIOSWhereUniqueInput
    /**
     * In case the PREMIOS found by the `where` argument doesn't exist, create a new PREMIOS with this data.
     */
    create: XOR<PREMIOSCreateInput, PREMIOSUncheckedCreateInput>
    /**
     * In case the PREMIOS was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PREMIOSUpdateInput, PREMIOSUncheckedUpdateInput>
  }

  /**
   * PREMIOS delete
   */
  export type PREMIOSDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PREMIOS
     */
    select?: PREMIOSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PREMIOS
     */
    omit?: PREMIOSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PREMIOSInclude<ExtArgs> | null
    /**
     * Filter which PREMIOS to delete.
     */
    where: PREMIOSWhereUniqueInput
  }

  /**
   * PREMIOS deleteMany
   */
  export type PREMIOSDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PREMIOS to delete
     */
    where?: PREMIOSWhereInput
    /**
     * Limit how many PREMIOS to delete.
     */
    limit?: number
  }

  /**
   * PREMIOS.USUARIO
   */
  export type PREMIOS$USUARIOArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the USUARIO
     */
    select?: USUARIOSelect<ExtArgs> | null
    /**
     * Omit specific fields from the USUARIO
     */
    omit?: USUARIOOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: USUARIOInclude<ExtArgs> | null
    where?: USUARIOWhereInput
  }

  /**
   * PREMIOS without action
   */
  export type PREMIOSDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PREMIOS
     */
    select?: PREMIOSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PREMIOS
     */
    omit?: PREMIOSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PREMIOSInclude<ExtArgs> | null
  }


  /**
   * Model SALA
   */

  export type AggregateSALA = {
    _count: SALACountAggregateOutputType | null
    _avg: SALAAvgAggregateOutputType | null
    _sum: SALASumAggregateOutputType | null
    _min: SALAMinAggregateOutputType | null
    _max: SALAMaxAggregateOutputType | null
  }

  export type SALAAvgAggregateOutputType = {
    id_sala: number | null
  }

  export type SALASumAggregateOutputType = {
    id_sala: number | null
  }

  export type SALAMinAggregateOutputType = {
    id_sala: number | null
    nome: string | null
    descricao: string | null
  }

  export type SALAMaxAggregateOutputType = {
    id_sala: number | null
    nome: string | null
    descricao: string | null
  }

  export type SALACountAggregateOutputType = {
    id_sala: number
    nome: number
    descricao: number
    _all: number
  }


  export type SALAAvgAggregateInputType = {
    id_sala?: true
  }

  export type SALASumAggregateInputType = {
    id_sala?: true
  }

  export type SALAMinAggregateInputType = {
    id_sala?: true
    nome?: true
    descricao?: true
  }

  export type SALAMaxAggregateInputType = {
    id_sala?: true
    nome?: true
    descricao?: true
  }

  export type SALACountAggregateInputType = {
    id_sala?: true
    nome?: true
    descricao?: true
    _all?: true
  }

  export type SALAAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SALA to aggregate.
     */
    where?: SALAWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SALAS to fetch.
     */
    orderBy?: SALAOrderByWithRelationInput | SALAOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SALAWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SALAS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SALAS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SALAS
    **/
    _count?: true | SALACountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SALAAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SALASumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SALAMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SALAMaxAggregateInputType
  }

  export type GetSALAAggregateType<T extends SALAAggregateArgs> = {
        [P in keyof T & keyof AggregateSALA]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSALA[P]>
      : GetScalarType<T[P], AggregateSALA[P]>
  }




  export type SALAGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SALAWhereInput
    orderBy?: SALAOrderByWithAggregationInput | SALAOrderByWithAggregationInput[]
    by: SALAScalarFieldEnum[] | SALAScalarFieldEnum
    having?: SALAScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SALACountAggregateInputType | true
    _avg?: SALAAvgAggregateInputType
    _sum?: SALASumAggregateInputType
    _min?: SALAMinAggregateInputType
    _max?: SALAMaxAggregateInputType
  }

  export type SALAGroupByOutputType = {
    id_sala: number
    nome: string
    descricao: string | null
    _count: SALACountAggregateOutputType | null
    _avg: SALAAvgAggregateOutputType | null
    _sum: SALASumAggregateOutputType | null
    _min: SALAMinAggregateOutputType | null
    _max: SALAMaxAggregateOutputType | null
  }

  type GetSALAGroupByPayload<T extends SALAGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SALAGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SALAGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SALAGroupByOutputType[P]>
            : GetScalarType<T[P], SALAGroupByOutputType[P]>
        }
      >
    >


  export type SALASelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_sala?: boolean
    nome?: boolean
    descricao?: boolean
    JOGO?: boolean | SALA$JOGOArgs<ExtArgs>
    _count?: boolean | SALACountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sALA"]>



  export type SALASelectScalar = {
    id_sala?: boolean
    nome?: boolean
    descricao?: boolean
  }

  export type SALAOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id_sala" | "nome" | "descricao", ExtArgs["result"]["sALA"]>
  export type SALAInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    JOGO?: boolean | SALA$JOGOArgs<ExtArgs>
    _count?: boolean | SALACountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $SALAPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SALA"
    objects: {
      JOGO: Prisma.$JOGOPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id_sala: number
      nome: string
      descricao: string | null
    }, ExtArgs["result"]["sALA"]>
    composites: {}
  }

  type SALAGetPayload<S extends boolean | null | undefined | SALADefaultArgs> = $Result.GetResult<Prisma.$SALAPayload, S>

  type SALACountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SALAFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SALACountAggregateInputType | true
    }

  export interface SALADelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SALA'], meta: { name: 'SALA' } }
    /**
     * Find zero or one SALA that matches the filter.
     * @param {SALAFindUniqueArgs} args - Arguments to find a SALA
     * @example
     * // Get one SALA
     * const sALA = await prisma.sALA.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SALAFindUniqueArgs>(args: SelectSubset<T, SALAFindUniqueArgs<ExtArgs>>): Prisma__SALAClient<$Result.GetResult<Prisma.$SALAPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SALA that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SALAFindUniqueOrThrowArgs} args - Arguments to find a SALA
     * @example
     * // Get one SALA
     * const sALA = await prisma.sALA.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SALAFindUniqueOrThrowArgs>(args: SelectSubset<T, SALAFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SALAClient<$Result.GetResult<Prisma.$SALAPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SALA that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SALAFindFirstArgs} args - Arguments to find a SALA
     * @example
     * // Get one SALA
     * const sALA = await prisma.sALA.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SALAFindFirstArgs>(args?: SelectSubset<T, SALAFindFirstArgs<ExtArgs>>): Prisma__SALAClient<$Result.GetResult<Prisma.$SALAPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SALA that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SALAFindFirstOrThrowArgs} args - Arguments to find a SALA
     * @example
     * // Get one SALA
     * const sALA = await prisma.sALA.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SALAFindFirstOrThrowArgs>(args?: SelectSubset<T, SALAFindFirstOrThrowArgs<ExtArgs>>): Prisma__SALAClient<$Result.GetResult<Prisma.$SALAPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SALAS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SALAFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SALAS
     * const sALAS = await prisma.sALA.findMany()
     * 
     * // Get first 10 SALAS
     * const sALAS = await prisma.sALA.findMany({ take: 10 })
     * 
     * // Only select the `id_sala`
     * const sALAWithId_salaOnly = await prisma.sALA.findMany({ select: { id_sala: true } })
     * 
     */
    findMany<T extends SALAFindManyArgs>(args?: SelectSubset<T, SALAFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SALAPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SALA.
     * @param {SALACreateArgs} args - Arguments to create a SALA.
     * @example
     * // Create one SALA
     * const SALA = await prisma.sALA.create({
     *   data: {
     *     // ... data to create a SALA
     *   }
     * })
     * 
     */
    create<T extends SALACreateArgs>(args: SelectSubset<T, SALACreateArgs<ExtArgs>>): Prisma__SALAClient<$Result.GetResult<Prisma.$SALAPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SALAS.
     * @param {SALACreateManyArgs} args - Arguments to create many SALAS.
     * @example
     * // Create many SALAS
     * const sALA = await prisma.sALA.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SALACreateManyArgs>(args?: SelectSubset<T, SALACreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SALA.
     * @param {SALADeleteArgs} args - Arguments to delete one SALA.
     * @example
     * // Delete one SALA
     * const SALA = await prisma.sALA.delete({
     *   where: {
     *     // ... filter to delete one SALA
     *   }
     * })
     * 
     */
    delete<T extends SALADeleteArgs>(args: SelectSubset<T, SALADeleteArgs<ExtArgs>>): Prisma__SALAClient<$Result.GetResult<Prisma.$SALAPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SALA.
     * @param {SALAUpdateArgs} args - Arguments to update one SALA.
     * @example
     * // Update one SALA
     * const sALA = await prisma.sALA.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SALAUpdateArgs>(args: SelectSubset<T, SALAUpdateArgs<ExtArgs>>): Prisma__SALAClient<$Result.GetResult<Prisma.$SALAPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SALAS.
     * @param {SALADeleteManyArgs} args - Arguments to filter SALAS to delete.
     * @example
     * // Delete a few SALAS
     * const { count } = await prisma.sALA.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SALADeleteManyArgs>(args?: SelectSubset<T, SALADeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SALAS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SALAUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SALAS
     * const sALA = await prisma.sALA.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SALAUpdateManyArgs>(args: SelectSubset<T, SALAUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SALA.
     * @param {SALAUpsertArgs} args - Arguments to update or create a SALA.
     * @example
     * // Update or create a SALA
     * const sALA = await prisma.sALA.upsert({
     *   create: {
     *     // ... data to create a SALA
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SALA we want to update
     *   }
     * })
     */
    upsert<T extends SALAUpsertArgs>(args: SelectSubset<T, SALAUpsertArgs<ExtArgs>>): Prisma__SALAClient<$Result.GetResult<Prisma.$SALAPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SALAS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SALACountArgs} args - Arguments to filter SALAS to count.
     * @example
     * // Count the number of SALAS
     * const count = await prisma.sALA.count({
     *   where: {
     *     // ... the filter for the SALAS we want to count
     *   }
     * })
    **/
    count<T extends SALACountArgs>(
      args?: Subset<T, SALACountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SALACountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SALA.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SALAAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SALAAggregateArgs>(args: Subset<T, SALAAggregateArgs>): Prisma.PrismaPromise<GetSALAAggregateType<T>>

    /**
     * Group by SALA.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SALAGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SALAGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SALAGroupByArgs['orderBy'] }
        : { orderBy?: SALAGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SALAGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSALAGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SALA model
   */
  readonly fields: SALAFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SALA.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SALAClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    JOGO<T extends SALA$JOGOArgs<ExtArgs> = {}>(args?: Subset<T, SALA$JOGOArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JOGOPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SALA model
   */
  interface SALAFieldRefs {
    readonly id_sala: FieldRef<"SALA", 'Int'>
    readonly nome: FieldRef<"SALA", 'String'>
    readonly descricao: FieldRef<"SALA", 'String'>
  }
    

  // Custom InputTypes
  /**
   * SALA findUnique
   */
  export type SALAFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SALA
     */
    select?: SALASelect<ExtArgs> | null
    /**
     * Omit specific fields from the SALA
     */
    omit?: SALAOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SALAInclude<ExtArgs> | null
    /**
     * Filter, which SALA to fetch.
     */
    where: SALAWhereUniqueInput
  }

  /**
   * SALA findUniqueOrThrow
   */
  export type SALAFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SALA
     */
    select?: SALASelect<ExtArgs> | null
    /**
     * Omit specific fields from the SALA
     */
    omit?: SALAOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SALAInclude<ExtArgs> | null
    /**
     * Filter, which SALA to fetch.
     */
    where: SALAWhereUniqueInput
  }

  /**
   * SALA findFirst
   */
  export type SALAFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SALA
     */
    select?: SALASelect<ExtArgs> | null
    /**
     * Omit specific fields from the SALA
     */
    omit?: SALAOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SALAInclude<ExtArgs> | null
    /**
     * Filter, which SALA to fetch.
     */
    where?: SALAWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SALAS to fetch.
     */
    orderBy?: SALAOrderByWithRelationInput | SALAOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SALAS.
     */
    cursor?: SALAWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SALAS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SALAS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SALAS.
     */
    distinct?: SALAScalarFieldEnum | SALAScalarFieldEnum[]
  }

  /**
   * SALA findFirstOrThrow
   */
  export type SALAFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SALA
     */
    select?: SALASelect<ExtArgs> | null
    /**
     * Omit specific fields from the SALA
     */
    omit?: SALAOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SALAInclude<ExtArgs> | null
    /**
     * Filter, which SALA to fetch.
     */
    where?: SALAWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SALAS to fetch.
     */
    orderBy?: SALAOrderByWithRelationInput | SALAOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SALAS.
     */
    cursor?: SALAWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SALAS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SALAS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SALAS.
     */
    distinct?: SALAScalarFieldEnum | SALAScalarFieldEnum[]
  }

  /**
   * SALA findMany
   */
  export type SALAFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SALA
     */
    select?: SALASelect<ExtArgs> | null
    /**
     * Omit specific fields from the SALA
     */
    omit?: SALAOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SALAInclude<ExtArgs> | null
    /**
     * Filter, which SALAS to fetch.
     */
    where?: SALAWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SALAS to fetch.
     */
    orderBy?: SALAOrderByWithRelationInput | SALAOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SALAS.
     */
    cursor?: SALAWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SALAS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SALAS.
     */
    skip?: number
    distinct?: SALAScalarFieldEnum | SALAScalarFieldEnum[]
  }

  /**
   * SALA create
   */
  export type SALACreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SALA
     */
    select?: SALASelect<ExtArgs> | null
    /**
     * Omit specific fields from the SALA
     */
    omit?: SALAOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SALAInclude<ExtArgs> | null
    /**
     * The data needed to create a SALA.
     */
    data: XOR<SALACreateInput, SALAUncheckedCreateInput>
  }

  /**
   * SALA createMany
   */
  export type SALACreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SALAS.
     */
    data: SALACreateManyInput | SALACreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SALA update
   */
  export type SALAUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SALA
     */
    select?: SALASelect<ExtArgs> | null
    /**
     * Omit specific fields from the SALA
     */
    omit?: SALAOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SALAInclude<ExtArgs> | null
    /**
     * The data needed to update a SALA.
     */
    data: XOR<SALAUpdateInput, SALAUncheckedUpdateInput>
    /**
     * Choose, which SALA to update.
     */
    where: SALAWhereUniqueInput
  }

  /**
   * SALA updateMany
   */
  export type SALAUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SALAS.
     */
    data: XOR<SALAUpdateManyMutationInput, SALAUncheckedUpdateManyInput>
    /**
     * Filter which SALAS to update
     */
    where?: SALAWhereInput
    /**
     * Limit how many SALAS to update.
     */
    limit?: number
  }

  /**
   * SALA upsert
   */
  export type SALAUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SALA
     */
    select?: SALASelect<ExtArgs> | null
    /**
     * Omit specific fields from the SALA
     */
    omit?: SALAOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SALAInclude<ExtArgs> | null
    /**
     * The filter to search for the SALA to update in case it exists.
     */
    where: SALAWhereUniqueInput
    /**
     * In case the SALA found by the `where` argument doesn't exist, create a new SALA with this data.
     */
    create: XOR<SALACreateInput, SALAUncheckedCreateInput>
    /**
     * In case the SALA was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SALAUpdateInput, SALAUncheckedUpdateInput>
  }

  /**
   * SALA delete
   */
  export type SALADeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SALA
     */
    select?: SALASelect<ExtArgs> | null
    /**
     * Omit specific fields from the SALA
     */
    omit?: SALAOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SALAInclude<ExtArgs> | null
    /**
     * Filter which SALA to delete.
     */
    where: SALAWhereUniqueInput
  }

  /**
   * SALA deleteMany
   */
  export type SALADeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SALAS to delete
     */
    where?: SALAWhereInput
    /**
     * Limit how many SALAS to delete.
     */
    limit?: number
  }

  /**
   * SALA.JOGO
   */
  export type SALA$JOGOArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JOGO
     */
    select?: JOGOSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JOGO
     */
    omit?: JOGOOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JOGOInclude<ExtArgs> | null
    where?: JOGOWhereInput
    orderBy?: JOGOOrderByWithRelationInput | JOGOOrderByWithRelationInput[]
    cursor?: JOGOWhereUniqueInput
    take?: number
    skip?: number
    distinct?: JOGOScalarFieldEnum | JOGOScalarFieldEnum[]
  }

  /**
   * SALA without action
   */
  export type SALADefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SALA
     */
    select?: SALASelect<ExtArgs> | null
    /**
     * Omit specific fields from the SALA
     */
    omit?: SALAOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SALAInclude<ExtArgs> | null
  }


  /**
   * Model USUARIO
   */

  export type AggregateUSUARIO = {
    _count: USUARIOCountAggregateOutputType | null
    _avg: USUARIOAvgAggregateOutputType | null
    _sum: USUARIOSumAggregateOutputType | null
    _min: USUARIOMinAggregateOutputType | null
    _max: USUARIOMaxAggregateOutputType | null
  }

  export type USUARIOAvgAggregateOutputType = {
    id_usuario: number | null
    creditos: Decimal | null
  }

  export type USUARIOSumAggregateOutputType = {
    id_usuario: number | null
    creditos: Decimal | null
  }

  export type USUARIOMinAggregateOutputType = {
    id_usuario: number | null
    nome: string | null
    email: string | null
    senha: string | null
    creditos: Decimal | null
    is_admin: boolean | null
  }

  export type USUARIOMaxAggregateOutputType = {
    id_usuario: number | null
    nome: string | null
    email: string | null
    senha: string | null
    creditos: Decimal | null
    is_admin: boolean | null
  }

  export type USUARIOCountAggregateOutputType = {
    id_usuario: number
    nome: number
    email: number
    senha: number
    creditos: number
    is_admin: number
    _all: number
  }


  export type USUARIOAvgAggregateInputType = {
    id_usuario?: true
    creditos?: true
  }

  export type USUARIOSumAggregateInputType = {
    id_usuario?: true
    creditos?: true
  }

  export type USUARIOMinAggregateInputType = {
    id_usuario?: true
    nome?: true
    email?: true
    senha?: true
    creditos?: true
    is_admin?: true
  }

  export type USUARIOMaxAggregateInputType = {
    id_usuario?: true
    nome?: true
    email?: true
    senha?: true
    creditos?: true
    is_admin?: true
  }

  export type USUARIOCountAggregateInputType = {
    id_usuario?: true
    nome?: true
    email?: true
    senha?: true
    creditos?: true
    is_admin?: true
    _all?: true
  }

  export type USUARIOAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which USUARIO to aggregate.
     */
    where?: USUARIOWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of USUARIOS to fetch.
     */
    orderBy?: USUARIOOrderByWithRelationInput | USUARIOOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: USUARIOWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` USUARIOS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` USUARIOS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned USUARIOS
    **/
    _count?: true | USUARIOCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: USUARIOAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: USUARIOSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: USUARIOMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: USUARIOMaxAggregateInputType
  }

  export type GetUSUARIOAggregateType<T extends USUARIOAggregateArgs> = {
        [P in keyof T & keyof AggregateUSUARIO]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUSUARIO[P]>
      : GetScalarType<T[P], AggregateUSUARIO[P]>
  }




  export type USUARIOGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: USUARIOWhereInput
    orderBy?: USUARIOOrderByWithAggregationInput | USUARIOOrderByWithAggregationInput[]
    by: USUARIOScalarFieldEnum[] | USUARIOScalarFieldEnum
    having?: USUARIOScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: USUARIOCountAggregateInputType | true
    _avg?: USUARIOAvgAggregateInputType
    _sum?: USUARIOSumAggregateInputType
    _min?: USUARIOMinAggregateInputType
    _max?: USUARIOMaxAggregateInputType
  }

  export type USUARIOGroupByOutputType = {
    id_usuario: number
    nome: string
    email: string
    senha: string
    creditos: Decimal
    is_admin: boolean
    _count: USUARIOCountAggregateOutputType | null
    _avg: USUARIOAvgAggregateOutputType | null
    _sum: USUARIOSumAggregateOutputType | null
    _min: USUARIOMinAggregateOutputType | null
    _max: USUARIOMaxAggregateOutputType | null
  }

  type GetUSUARIOGroupByPayload<T extends USUARIOGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<USUARIOGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof USUARIOGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], USUARIOGroupByOutputType[P]>
            : GetScalarType<T[P], USUARIOGroupByOutputType[P]>
        }
      >
    >


  export type USUARIOSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_usuario?: boolean
    nome?: boolean
    email?: boolean
    senha?: boolean
    creditos?: boolean
    is_admin?: boolean
    CARTELA?: boolean | USUARIO$CARTELAArgs<ExtArgs>
    JOGO?: boolean | USUARIO$JOGOArgs<ExtArgs>
    PREMIOS?: boolean | USUARIO$PREMIOSArgs<ExtArgs>
    _count?: boolean | USUARIOCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["uSUARIO"]>



  export type USUARIOSelectScalar = {
    id_usuario?: boolean
    nome?: boolean
    email?: boolean
    senha?: boolean
    creditos?: boolean
    is_admin?: boolean
  }

  export type USUARIOOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id_usuario" | "nome" | "email" | "senha" | "creditos" | "is_admin", ExtArgs["result"]["uSUARIO"]>
  export type USUARIOInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    CARTELA?: boolean | USUARIO$CARTELAArgs<ExtArgs>
    JOGO?: boolean | USUARIO$JOGOArgs<ExtArgs>
    PREMIOS?: boolean | USUARIO$PREMIOSArgs<ExtArgs>
    _count?: boolean | USUARIOCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $USUARIOPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "USUARIO"
    objects: {
      CARTELA: Prisma.$CARTELAPayload<ExtArgs>[]
      JOGO: Prisma.$JOGOPayload<ExtArgs>[]
      PREMIOS: Prisma.$PREMIOSPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id_usuario: number
      nome: string
      email: string
      senha: string
      creditos: Prisma.Decimal
      is_admin: boolean
    }, ExtArgs["result"]["uSUARIO"]>
    composites: {}
  }

  type USUARIOGetPayload<S extends boolean | null | undefined | USUARIODefaultArgs> = $Result.GetResult<Prisma.$USUARIOPayload, S>

  type USUARIOCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<USUARIOFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: USUARIOCountAggregateInputType | true
    }

  export interface USUARIODelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['USUARIO'], meta: { name: 'USUARIO' } }
    /**
     * Find zero or one USUARIO that matches the filter.
     * @param {USUARIOFindUniqueArgs} args - Arguments to find a USUARIO
     * @example
     * // Get one USUARIO
     * const uSUARIO = await prisma.uSUARIO.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends USUARIOFindUniqueArgs>(args: SelectSubset<T, USUARIOFindUniqueArgs<ExtArgs>>): Prisma__USUARIOClient<$Result.GetResult<Prisma.$USUARIOPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one USUARIO that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {USUARIOFindUniqueOrThrowArgs} args - Arguments to find a USUARIO
     * @example
     * // Get one USUARIO
     * const uSUARIO = await prisma.uSUARIO.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends USUARIOFindUniqueOrThrowArgs>(args: SelectSubset<T, USUARIOFindUniqueOrThrowArgs<ExtArgs>>): Prisma__USUARIOClient<$Result.GetResult<Prisma.$USUARIOPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first USUARIO that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {USUARIOFindFirstArgs} args - Arguments to find a USUARIO
     * @example
     * // Get one USUARIO
     * const uSUARIO = await prisma.uSUARIO.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends USUARIOFindFirstArgs>(args?: SelectSubset<T, USUARIOFindFirstArgs<ExtArgs>>): Prisma__USUARIOClient<$Result.GetResult<Prisma.$USUARIOPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first USUARIO that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {USUARIOFindFirstOrThrowArgs} args - Arguments to find a USUARIO
     * @example
     * // Get one USUARIO
     * const uSUARIO = await prisma.uSUARIO.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends USUARIOFindFirstOrThrowArgs>(args?: SelectSubset<T, USUARIOFindFirstOrThrowArgs<ExtArgs>>): Prisma__USUARIOClient<$Result.GetResult<Prisma.$USUARIOPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more USUARIOS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {USUARIOFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all USUARIOS
     * const uSUARIOS = await prisma.uSUARIO.findMany()
     * 
     * // Get first 10 USUARIOS
     * const uSUARIOS = await prisma.uSUARIO.findMany({ take: 10 })
     * 
     * // Only select the `id_usuario`
     * const uSUARIOWithId_usuarioOnly = await prisma.uSUARIO.findMany({ select: { id_usuario: true } })
     * 
     */
    findMany<T extends USUARIOFindManyArgs>(args?: SelectSubset<T, USUARIOFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$USUARIOPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a USUARIO.
     * @param {USUARIOCreateArgs} args - Arguments to create a USUARIO.
     * @example
     * // Create one USUARIO
     * const USUARIO = await prisma.uSUARIO.create({
     *   data: {
     *     // ... data to create a USUARIO
     *   }
     * })
     * 
     */
    create<T extends USUARIOCreateArgs>(args: SelectSubset<T, USUARIOCreateArgs<ExtArgs>>): Prisma__USUARIOClient<$Result.GetResult<Prisma.$USUARIOPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many USUARIOS.
     * @param {USUARIOCreateManyArgs} args - Arguments to create many USUARIOS.
     * @example
     * // Create many USUARIOS
     * const uSUARIO = await prisma.uSUARIO.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends USUARIOCreateManyArgs>(args?: SelectSubset<T, USUARIOCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a USUARIO.
     * @param {USUARIODeleteArgs} args - Arguments to delete one USUARIO.
     * @example
     * // Delete one USUARIO
     * const USUARIO = await prisma.uSUARIO.delete({
     *   where: {
     *     // ... filter to delete one USUARIO
     *   }
     * })
     * 
     */
    delete<T extends USUARIODeleteArgs>(args: SelectSubset<T, USUARIODeleteArgs<ExtArgs>>): Prisma__USUARIOClient<$Result.GetResult<Prisma.$USUARIOPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one USUARIO.
     * @param {USUARIOUpdateArgs} args - Arguments to update one USUARIO.
     * @example
     * // Update one USUARIO
     * const uSUARIO = await prisma.uSUARIO.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends USUARIOUpdateArgs>(args: SelectSubset<T, USUARIOUpdateArgs<ExtArgs>>): Prisma__USUARIOClient<$Result.GetResult<Prisma.$USUARIOPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more USUARIOS.
     * @param {USUARIODeleteManyArgs} args - Arguments to filter USUARIOS to delete.
     * @example
     * // Delete a few USUARIOS
     * const { count } = await prisma.uSUARIO.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends USUARIODeleteManyArgs>(args?: SelectSubset<T, USUARIODeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more USUARIOS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {USUARIOUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many USUARIOS
     * const uSUARIO = await prisma.uSUARIO.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends USUARIOUpdateManyArgs>(args: SelectSubset<T, USUARIOUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one USUARIO.
     * @param {USUARIOUpsertArgs} args - Arguments to update or create a USUARIO.
     * @example
     * // Update or create a USUARIO
     * const uSUARIO = await prisma.uSUARIO.upsert({
     *   create: {
     *     // ... data to create a USUARIO
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the USUARIO we want to update
     *   }
     * })
     */
    upsert<T extends USUARIOUpsertArgs>(args: SelectSubset<T, USUARIOUpsertArgs<ExtArgs>>): Prisma__USUARIOClient<$Result.GetResult<Prisma.$USUARIOPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of USUARIOS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {USUARIOCountArgs} args - Arguments to filter USUARIOS to count.
     * @example
     * // Count the number of USUARIOS
     * const count = await prisma.uSUARIO.count({
     *   where: {
     *     // ... the filter for the USUARIOS we want to count
     *   }
     * })
    **/
    count<T extends USUARIOCountArgs>(
      args?: Subset<T, USUARIOCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], USUARIOCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a USUARIO.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {USUARIOAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends USUARIOAggregateArgs>(args: Subset<T, USUARIOAggregateArgs>): Prisma.PrismaPromise<GetUSUARIOAggregateType<T>>

    /**
     * Group by USUARIO.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {USUARIOGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends USUARIOGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: USUARIOGroupByArgs['orderBy'] }
        : { orderBy?: USUARIOGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, USUARIOGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUSUARIOGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the USUARIO model
   */
  readonly fields: USUARIOFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for USUARIO.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__USUARIOClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    CARTELA<T extends USUARIO$CARTELAArgs<ExtArgs> = {}>(args?: Subset<T, USUARIO$CARTELAArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CARTELAPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    JOGO<T extends USUARIO$JOGOArgs<ExtArgs> = {}>(args?: Subset<T, USUARIO$JOGOArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JOGOPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    PREMIOS<T extends USUARIO$PREMIOSArgs<ExtArgs> = {}>(args?: Subset<T, USUARIO$PREMIOSArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PREMIOSPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the USUARIO model
   */
  interface USUARIOFieldRefs {
    readonly id_usuario: FieldRef<"USUARIO", 'Int'>
    readonly nome: FieldRef<"USUARIO", 'String'>
    readonly email: FieldRef<"USUARIO", 'String'>
    readonly senha: FieldRef<"USUARIO", 'String'>
    readonly creditos: FieldRef<"USUARIO", 'Decimal'>
    readonly is_admin: FieldRef<"USUARIO", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * USUARIO findUnique
   */
  export type USUARIOFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the USUARIO
     */
    select?: USUARIOSelect<ExtArgs> | null
    /**
     * Omit specific fields from the USUARIO
     */
    omit?: USUARIOOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: USUARIOInclude<ExtArgs> | null
    /**
     * Filter, which USUARIO to fetch.
     */
    where: USUARIOWhereUniqueInput
  }

  /**
   * USUARIO findUniqueOrThrow
   */
  export type USUARIOFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the USUARIO
     */
    select?: USUARIOSelect<ExtArgs> | null
    /**
     * Omit specific fields from the USUARIO
     */
    omit?: USUARIOOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: USUARIOInclude<ExtArgs> | null
    /**
     * Filter, which USUARIO to fetch.
     */
    where: USUARIOWhereUniqueInput
  }

  /**
   * USUARIO findFirst
   */
  export type USUARIOFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the USUARIO
     */
    select?: USUARIOSelect<ExtArgs> | null
    /**
     * Omit specific fields from the USUARIO
     */
    omit?: USUARIOOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: USUARIOInclude<ExtArgs> | null
    /**
     * Filter, which USUARIO to fetch.
     */
    where?: USUARIOWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of USUARIOS to fetch.
     */
    orderBy?: USUARIOOrderByWithRelationInput | USUARIOOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for USUARIOS.
     */
    cursor?: USUARIOWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` USUARIOS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` USUARIOS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of USUARIOS.
     */
    distinct?: USUARIOScalarFieldEnum | USUARIOScalarFieldEnum[]
  }

  /**
   * USUARIO findFirstOrThrow
   */
  export type USUARIOFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the USUARIO
     */
    select?: USUARIOSelect<ExtArgs> | null
    /**
     * Omit specific fields from the USUARIO
     */
    omit?: USUARIOOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: USUARIOInclude<ExtArgs> | null
    /**
     * Filter, which USUARIO to fetch.
     */
    where?: USUARIOWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of USUARIOS to fetch.
     */
    orderBy?: USUARIOOrderByWithRelationInput | USUARIOOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for USUARIOS.
     */
    cursor?: USUARIOWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` USUARIOS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` USUARIOS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of USUARIOS.
     */
    distinct?: USUARIOScalarFieldEnum | USUARIOScalarFieldEnum[]
  }

  /**
   * USUARIO findMany
   */
  export type USUARIOFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the USUARIO
     */
    select?: USUARIOSelect<ExtArgs> | null
    /**
     * Omit specific fields from the USUARIO
     */
    omit?: USUARIOOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: USUARIOInclude<ExtArgs> | null
    /**
     * Filter, which USUARIOS to fetch.
     */
    where?: USUARIOWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of USUARIOS to fetch.
     */
    orderBy?: USUARIOOrderByWithRelationInput | USUARIOOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing USUARIOS.
     */
    cursor?: USUARIOWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` USUARIOS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` USUARIOS.
     */
    skip?: number
    distinct?: USUARIOScalarFieldEnum | USUARIOScalarFieldEnum[]
  }

  /**
   * USUARIO create
   */
  export type USUARIOCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the USUARIO
     */
    select?: USUARIOSelect<ExtArgs> | null
    /**
     * Omit specific fields from the USUARIO
     */
    omit?: USUARIOOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: USUARIOInclude<ExtArgs> | null
    /**
     * The data needed to create a USUARIO.
     */
    data: XOR<USUARIOCreateInput, USUARIOUncheckedCreateInput>
  }

  /**
   * USUARIO createMany
   */
  export type USUARIOCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many USUARIOS.
     */
    data: USUARIOCreateManyInput | USUARIOCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * USUARIO update
   */
  export type USUARIOUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the USUARIO
     */
    select?: USUARIOSelect<ExtArgs> | null
    /**
     * Omit specific fields from the USUARIO
     */
    omit?: USUARIOOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: USUARIOInclude<ExtArgs> | null
    /**
     * The data needed to update a USUARIO.
     */
    data: XOR<USUARIOUpdateInput, USUARIOUncheckedUpdateInput>
    /**
     * Choose, which USUARIO to update.
     */
    where: USUARIOWhereUniqueInput
  }

  /**
   * USUARIO updateMany
   */
  export type USUARIOUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update USUARIOS.
     */
    data: XOR<USUARIOUpdateManyMutationInput, USUARIOUncheckedUpdateManyInput>
    /**
     * Filter which USUARIOS to update
     */
    where?: USUARIOWhereInput
    /**
     * Limit how many USUARIOS to update.
     */
    limit?: number
  }

  /**
   * USUARIO upsert
   */
  export type USUARIOUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the USUARIO
     */
    select?: USUARIOSelect<ExtArgs> | null
    /**
     * Omit specific fields from the USUARIO
     */
    omit?: USUARIOOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: USUARIOInclude<ExtArgs> | null
    /**
     * The filter to search for the USUARIO to update in case it exists.
     */
    where: USUARIOWhereUniqueInput
    /**
     * In case the USUARIO found by the `where` argument doesn't exist, create a new USUARIO with this data.
     */
    create: XOR<USUARIOCreateInput, USUARIOUncheckedCreateInput>
    /**
     * In case the USUARIO was found with the provided `where` argument, update it with this data.
     */
    update: XOR<USUARIOUpdateInput, USUARIOUncheckedUpdateInput>
  }

  /**
   * USUARIO delete
   */
  export type USUARIODeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the USUARIO
     */
    select?: USUARIOSelect<ExtArgs> | null
    /**
     * Omit specific fields from the USUARIO
     */
    omit?: USUARIOOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: USUARIOInclude<ExtArgs> | null
    /**
     * Filter which USUARIO to delete.
     */
    where: USUARIOWhereUniqueInput
  }

  /**
   * USUARIO deleteMany
   */
  export type USUARIODeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which USUARIOS to delete
     */
    where?: USUARIOWhereInput
    /**
     * Limit how many USUARIOS to delete.
     */
    limit?: number
  }

  /**
   * USUARIO.CARTELA
   */
  export type USUARIO$CARTELAArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CARTELA
     */
    select?: CARTELASelect<ExtArgs> | null
    /**
     * Omit specific fields from the CARTELA
     */
    omit?: CARTELAOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CARTELAInclude<ExtArgs> | null
    where?: CARTELAWhereInput
    orderBy?: CARTELAOrderByWithRelationInput | CARTELAOrderByWithRelationInput[]
    cursor?: CARTELAWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CARTELAScalarFieldEnum | CARTELAScalarFieldEnum[]
  }

  /**
   * USUARIO.JOGO
   */
  export type USUARIO$JOGOArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JOGO
     */
    select?: JOGOSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JOGO
     */
    omit?: JOGOOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JOGOInclude<ExtArgs> | null
    where?: JOGOWhereInput
    orderBy?: JOGOOrderByWithRelationInput | JOGOOrderByWithRelationInput[]
    cursor?: JOGOWhereUniqueInput
    take?: number
    skip?: number
    distinct?: JOGOScalarFieldEnum | JOGOScalarFieldEnum[]
  }

  /**
   * USUARIO.PREMIOS
   */
  export type USUARIO$PREMIOSArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PREMIOS
     */
    select?: PREMIOSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PREMIOS
     */
    omit?: PREMIOSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PREMIOSInclude<ExtArgs> | null
    where?: PREMIOSWhereInput
    orderBy?: PREMIOSOrderByWithRelationInput | PREMIOSOrderByWithRelationInput[]
    cursor?: PREMIOSWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PREMIOSScalarFieldEnum | PREMIOSScalarFieldEnum[]
  }

  /**
   * USUARIO without action
   */
  export type USUARIODefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the USUARIO
     */
    select?: USUARIOSelect<ExtArgs> | null
    /**
     * Omit specific fields from the USUARIO
     */
    omit?: USUARIOOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: USUARIOInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const CARTELAScalarFieldEnum: {
    id_cartela: 'id_cartela',
    id_usuario: 'id_usuario',
    id_jogo: 'id_jogo'
  };

  export type CARTELAScalarFieldEnum = (typeof CARTELAScalarFieldEnum)[keyof typeof CARTELAScalarFieldEnum]


  export const JOGOScalarFieldEnum: {
    id_jogo: 'id_jogo',
    data_hora: 'data_hora',
    id_sala: 'id_sala',
    id_usuario_vencedor: 'id_usuario_vencedor',
    preco_cartela: 'preco_cartela'
  };

  export type JOGOScalarFieldEnum = (typeof JOGOScalarFieldEnum)[keyof typeof JOGOScalarFieldEnum]


  export const NUMEROS_CARTELAScalarFieldEnum: {
    id_numero_cartela: 'id_numero_cartela',
    numero: 'numero',
    id_cartela: 'id_cartela'
  };

  export type NUMEROS_CARTELAScalarFieldEnum = (typeof NUMEROS_CARTELAScalarFieldEnum)[keyof typeof NUMEROS_CARTELAScalarFieldEnum]


  export const NUMEROS_SORTEADOSScalarFieldEnum: {
    id_numero_sorteado: 'id_numero_sorteado',
    numero: 'numero',
    ordem_sorteio: 'ordem_sorteio',
    id_jogo: 'id_jogo'
  };

  export type NUMEROS_SORTEADOSScalarFieldEnum = (typeof NUMEROS_SORTEADOSScalarFieldEnum)[keyof typeof NUMEROS_SORTEADOSScalarFieldEnum]


  export const PREMIOSScalarFieldEnum: {
    id_premio: 'id_premio',
    descricao: 'descricao',
    valor: 'valor',
    id_usuario: 'id_usuario',
    id_jogo: 'id_jogo'
  };

  export type PREMIOSScalarFieldEnum = (typeof PREMIOSScalarFieldEnum)[keyof typeof PREMIOSScalarFieldEnum]


  export const SALAScalarFieldEnum: {
    id_sala: 'id_sala',
    nome: 'nome',
    descricao: 'descricao'
  };

  export type SALAScalarFieldEnum = (typeof SALAScalarFieldEnum)[keyof typeof SALAScalarFieldEnum]


  export const USUARIOScalarFieldEnum: {
    id_usuario: 'id_usuario',
    nome: 'nome',
    email: 'email',
    senha: 'senha',
    creditos: 'creditos',
    is_admin: 'is_admin'
  };

  export type USUARIOScalarFieldEnum = (typeof USUARIOScalarFieldEnum)[keyof typeof USUARIOScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const PREMIOSOrderByRelevanceFieldEnum: {
    descricao: 'descricao'
  };

  export type PREMIOSOrderByRelevanceFieldEnum = (typeof PREMIOSOrderByRelevanceFieldEnum)[keyof typeof PREMIOSOrderByRelevanceFieldEnum]


  export const SALAOrderByRelevanceFieldEnum: {
    nome: 'nome',
    descricao: 'descricao'
  };

  export type SALAOrderByRelevanceFieldEnum = (typeof SALAOrderByRelevanceFieldEnum)[keyof typeof SALAOrderByRelevanceFieldEnum]


  export const USUARIOOrderByRelevanceFieldEnum: {
    nome: 'nome',
    email: 'email',
    senha: 'senha'
  };

  export type USUARIOOrderByRelevanceFieldEnum = (typeof USUARIOOrderByRelevanceFieldEnum)[keyof typeof USUARIOOrderByRelevanceFieldEnum]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    
  /**
   * Deep Input Types
   */


  export type CARTELAWhereInput = {
    AND?: CARTELAWhereInput | CARTELAWhereInput[]
    OR?: CARTELAWhereInput[]
    NOT?: CARTELAWhereInput | CARTELAWhereInput[]
    id_cartela?: IntFilter<"CARTELA"> | number
    id_usuario?: IntFilter<"CARTELA"> | number
    id_jogo?: IntFilter<"CARTELA"> | number
    JOGO?: XOR<JOGOScalarRelationFilter, JOGOWhereInput>
    USUARIO?: XOR<USUARIOScalarRelationFilter, USUARIOWhereInput>
    NUMEROS_CARTELA?: NUMEROS_CARTELAListRelationFilter
  }

  export type CARTELAOrderByWithRelationInput = {
    id_cartela?: SortOrder
    id_usuario?: SortOrder
    id_jogo?: SortOrder
    JOGO?: JOGOOrderByWithRelationInput
    USUARIO?: USUARIOOrderByWithRelationInput
    NUMEROS_CARTELA?: NUMEROS_CARTELAOrderByRelationAggregateInput
  }

  export type CARTELAWhereUniqueInput = Prisma.AtLeast<{
    id_cartela?: number
    AND?: CARTELAWhereInput | CARTELAWhereInput[]
    OR?: CARTELAWhereInput[]
    NOT?: CARTELAWhereInput | CARTELAWhereInput[]
    id_usuario?: IntFilter<"CARTELA"> | number
    id_jogo?: IntFilter<"CARTELA"> | number
    JOGO?: XOR<JOGOScalarRelationFilter, JOGOWhereInput>
    USUARIO?: XOR<USUARIOScalarRelationFilter, USUARIOWhereInput>
    NUMEROS_CARTELA?: NUMEROS_CARTELAListRelationFilter
  }, "id_cartela">

  export type CARTELAOrderByWithAggregationInput = {
    id_cartela?: SortOrder
    id_usuario?: SortOrder
    id_jogo?: SortOrder
    _count?: CARTELACountOrderByAggregateInput
    _avg?: CARTELAAvgOrderByAggregateInput
    _max?: CARTELAMaxOrderByAggregateInput
    _min?: CARTELAMinOrderByAggregateInput
    _sum?: CARTELASumOrderByAggregateInput
  }

  export type CARTELAScalarWhereWithAggregatesInput = {
    AND?: CARTELAScalarWhereWithAggregatesInput | CARTELAScalarWhereWithAggregatesInput[]
    OR?: CARTELAScalarWhereWithAggregatesInput[]
    NOT?: CARTELAScalarWhereWithAggregatesInput | CARTELAScalarWhereWithAggregatesInput[]
    id_cartela?: IntWithAggregatesFilter<"CARTELA"> | number
    id_usuario?: IntWithAggregatesFilter<"CARTELA"> | number
    id_jogo?: IntWithAggregatesFilter<"CARTELA"> | number
  }

  export type JOGOWhereInput = {
    AND?: JOGOWhereInput | JOGOWhereInput[]
    OR?: JOGOWhereInput[]
    NOT?: JOGOWhereInput | JOGOWhereInput[]
    id_jogo?: IntFilter<"JOGO"> | number
    data_hora?: DateTimeFilter<"JOGO"> | Date | string
    id_sala?: IntFilter<"JOGO"> | number
    id_usuario_vencedor?: IntNullableFilter<"JOGO"> | number | null
    preco_cartela?: DecimalFilter<"JOGO"> | Decimal | DecimalJsLike | number | string
    CARTELA?: CARTELAListRelationFilter
    SALA?: XOR<SALAScalarRelationFilter, SALAWhereInput>
    USUARIO?: XOR<USUARIONullableScalarRelationFilter, USUARIOWhereInput> | null
    NUMEROS_SORTEADOS?: NUMEROS_SORTEADOSListRelationFilter
    PREMIOS?: PREMIOSListRelationFilter
  }

  export type JOGOOrderByWithRelationInput = {
    id_jogo?: SortOrder
    data_hora?: SortOrder
    id_sala?: SortOrder
    id_usuario_vencedor?: SortOrderInput | SortOrder
    preco_cartela?: SortOrder
    CARTELA?: CARTELAOrderByRelationAggregateInput
    SALA?: SALAOrderByWithRelationInput
    USUARIO?: USUARIOOrderByWithRelationInput
    NUMEROS_SORTEADOS?: NUMEROS_SORTEADOSOrderByRelationAggregateInput
    PREMIOS?: PREMIOSOrderByRelationAggregateInput
  }

  export type JOGOWhereUniqueInput = Prisma.AtLeast<{
    id_jogo?: number
    AND?: JOGOWhereInput | JOGOWhereInput[]
    OR?: JOGOWhereInput[]
    NOT?: JOGOWhereInput | JOGOWhereInput[]
    data_hora?: DateTimeFilter<"JOGO"> | Date | string
    id_sala?: IntFilter<"JOGO"> | number
    id_usuario_vencedor?: IntNullableFilter<"JOGO"> | number | null
    preco_cartela?: DecimalFilter<"JOGO"> | Decimal | DecimalJsLike | number | string
    CARTELA?: CARTELAListRelationFilter
    SALA?: XOR<SALAScalarRelationFilter, SALAWhereInput>
    USUARIO?: XOR<USUARIONullableScalarRelationFilter, USUARIOWhereInput> | null
    NUMEROS_SORTEADOS?: NUMEROS_SORTEADOSListRelationFilter
    PREMIOS?: PREMIOSListRelationFilter
  }, "id_jogo">

  export type JOGOOrderByWithAggregationInput = {
    id_jogo?: SortOrder
    data_hora?: SortOrder
    id_sala?: SortOrder
    id_usuario_vencedor?: SortOrderInput | SortOrder
    preco_cartela?: SortOrder
    _count?: JOGOCountOrderByAggregateInput
    _avg?: JOGOAvgOrderByAggregateInput
    _max?: JOGOMaxOrderByAggregateInput
    _min?: JOGOMinOrderByAggregateInput
    _sum?: JOGOSumOrderByAggregateInput
  }

  export type JOGOScalarWhereWithAggregatesInput = {
    AND?: JOGOScalarWhereWithAggregatesInput | JOGOScalarWhereWithAggregatesInput[]
    OR?: JOGOScalarWhereWithAggregatesInput[]
    NOT?: JOGOScalarWhereWithAggregatesInput | JOGOScalarWhereWithAggregatesInput[]
    id_jogo?: IntWithAggregatesFilter<"JOGO"> | number
    data_hora?: DateTimeWithAggregatesFilter<"JOGO"> | Date | string
    id_sala?: IntWithAggregatesFilter<"JOGO"> | number
    id_usuario_vencedor?: IntNullableWithAggregatesFilter<"JOGO"> | number | null
    preco_cartela?: DecimalWithAggregatesFilter<"JOGO"> | Decimal | DecimalJsLike | number | string
  }

  export type NUMEROS_CARTELAWhereInput = {
    AND?: NUMEROS_CARTELAWhereInput | NUMEROS_CARTELAWhereInput[]
    OR?: NUMEROS_CARTELAWhereInput[]
    NOT?: NUMEROS_CARTELAWhereInput | NUMEROS_CARTELAWhereInput[]
    id_numero_cartela?: IntFilter<"NUMEROS_CARTELA"> | number
    numero?: IntFilter<"NUMEROS_CARTELA"> | number
    id_cartela?: IntFilter<"NUMEROS_CARTELA"> | number
    CARTELA?: XOR<CARTELAScalarRelationFilter, CARTELAWhereInput>
  }

  export type NUMEROS_CARTELAOrderByWithRelationInput = {
    id_numero_cartela?: SortOrder
    numero?: SortOrder
    id_cartela?: SortOrder
    CARTELA?: CARTELAOrderByWithRelationInput
  }

  export type NUMEROS_CARTELAWhereUniqueInput = Prisma.AtLeast<{
    id_numero_cartela?: number
    AND?: NUMEROS_CARTELAWhereInput | NUMEROS_CARTELAWhereInput[]
    OR?: NUMEROS_CARTELAWhereInput[]
    NOT?: NUMEROS_CARTELAWhereInput | NUMEROS_CARTELAWhereInput[]
    numero?: IntFilter<"NUMEROS_CARTELA"> | number
    id_cartela?: IntFilter<"NUMEROS_CARTELA"> | number
    CARTELA?: XOR<CARTELAScalarRelationFilter, CARTELAWhereInput>
  }, "id_numero_cartela">

  export type NUMEROS_CARTELAOrderByWithAggregationInput = {
    id_numero_cartela?: SortOrder
    numero?: SortOrder
    id_cartela?: SortOrder
    _count?: NUMEROS_CARTELACountOrderByAggregateInput
    _avg?: NUMEROS_CARTELAAvgOrderByAggregateInput
    _max?: NUMEROS_CARTELAMaxOrderByAggregateInput
    _min?: NUMEROS_CARTELAMinOrderByAggregateInput
    _sum?: NUMEROS_CARTELASumOrderByAggregateInput
  }

  export type NUMEROS_CARTELAScalarWhereWithAggregatesInput = {
    AND?: NUMEROS_CARTELAScalarWhereWithAggregatesInput | NUMEROS_CARTELAScalarWhereWithAggregatesInput[]
    OR?: NUMEROS_CARTELAScalarWhereWithAggregatesInput[]
    NOT?: NUMEROS_CARTELAScalarWhereWithAggregatesInput | NUMEROS_CARTELAScalarWhereWithAggregatesInput[]
    id_numero_cartela?: IntWithAggregatesFilter<"NUMEROS_CARTELA"> | number
    numero?: IntWithAggregatesFilter<"NUMEROS_CARTELA"> | number
    id_cartela?: IntWithAggregatesFilter<"NUMEROS_CARTELA"> | number
  }

  export type NUMEROS_SORTEADOSWhereInput = {
    AND?: NUMEROS_SORTEADOSWhereInput | NUMEROS_SORTEADOSWhereInput[]
    OR?: NUMEROS_SORTEADOSWhereInput[]
    NOT?: NUMEROS_SORTEADOSWhereInput | NUMEROS_SORTEADOSWhereInput[]
    id_numero_sorteado?: IntFilter<"NUMEROS_SORTEADOS"> | number
    numero?: IntFilter<"NUMEROS_SORTEADOS"> | number
    ordem_sorteio?: IntFilter<"NUMEROS_SORTEADOS"> | number
    id_jogo?: IntFilter<"NUMEROS_SORTEADOS"> | number
    JOGO?: XOR<JOGOScalarRelationFilter, JOGOWhereInput>
  }

  export type NUMEROS_SORTEADOSOrderByWithRelationInput = {
    id_numero_sorteado?: SortOrder
    numero?: SortOrder
    ordem_sorteio?: SortOrder
    id_jogo?: SortOrder
    JOGO?: JOGOOrderByWithRelationInput
  }

  export type NUMEROS_SORTEADOSWhereUniqueInput = Prisma.AtLeast<{
    id_numero_sorteado?: number
    AND?: NUMEROS_SORTEADOSWhereInput | NUMEROS_SORTEADOSWhereInput[]
    OR?: NUMEROS_SORTEADOSWhereInput[]
    NOT?: NUMEROS_SORTEADOSWhereInput | NUMEROS_SORTEADOSWhereInput[]
    numero?: IntFilter<"NUMEROS_SORTEADOS"> | number
    ordem_sorteio?: IntFilter<"NUMEROS_SORTEADOS"> | number
    id_jogo?: IntFilter<"NUMEROS_SORTEADOS"> | number
    JOGO?: XOR<JOGOScalarRelationFilter, JOGOWhereInput>
  }, "id_numero_sorteado">

  export type NUMEROS_SORTEADOSOrderByWithAggregationInput = {
    id_numero_sorteado?: SortOrder
    numero?: SortOrder
    ordem_sorteio?: SortOrder
    id_jogo?: SortOrder
    _count?: NUMEROS_SORTEADOSCountOrderByAggregateInput
    _avg?: NUMEROS_SORTEADOSAvgOrderByAggregateInput
    _max?: NUMEROS_SORTEADOSMaxOrderByAggregateInput
    _min?: NUMEROS_SORTEADOSMinOrderByAggregateInput
    _sum?: NUMEROS_SORTEADOSSumOrderByAggregateInput
  }

  export type NUMEROS_SORTEADOSScalarWhereWithAggregatesInput = {
    AND?: NUMEROS_SORTEADOSScalarWhereWithAggregatesInput | NUMEROS_SORTEADOSScalarWhereWithAggregatesInput[]
    OR?: NUMEROS_SORTEADOSScalarWhereWithAggregatesInput[]
    NOT?: NUMEROS_SORTEADOSScalarWhereWithAggregatesInput | NUMEROS_SORTEADOSScalarWhereWithAggregatesInput[]
    id_numero_sorteado?: IntWithAggregatesFilter<"NUMEROS_SORTEADOS"> | number
    numero?: IntWithAggregatesFilter<"NUMEROS_SORTEADOS"> | number
    ordem_sorteio?: IntWithAggregatesFilter<"NUMEROS_SORTEADOS"> | number
    id_jogo?: IntWithAggregatesFilter<"NUMEROS_SORTEADOS"> | number
  }

  export type PREMIOSWhereInput = {
    AND?: PREMIOSWhereInput | PREMIOSWhereInput[]
    OR?: PREMIOSWhereInput[]
    NOT?: PREMIOSWhereInput | PREMIOSWhereInput[]
    id_premio?: IntFilter<"PREMIOS"> | number
    descricao?: StringFilter<"PREMIOS"> | string
    valor?: DecimalFilter<"PREMIOS"> | Decimal | DecimalJsLike | number | string
    id_usuario?: IntNullableFilter<"PREMIOS"> | number | null
    id_jogo?: IntFilter<"PREMIOS"> | number
    JOGO?: XOR<JOGOScalarRelationFilter, JOGOWhereInput>
    USUARIO?: XOR<USUARIONullableScalarRelationFilter, USUARIOWhereInput> | null
  }

  export type PREMIOSOrderByWithRelationInput = {
    id_premio?: SortOrder
    descricao?: SortOrder
    valor?: SortOrder
    id_usuario?: SortOrderInput | SortOrder
    id_jogo?: SortOrder
    JOGO?: JOGOOrderByWithRelationInput
    USUARIO?: USUARIOOrderByWithRelationInput
    _relevance?: PREMIOSOrderByRelevanceInput
  }

  export type PREMIOSWhereUniqueInput = Prisma.AtLeast<{
    id_premio?: number
    AND?: PREMIOSWhereInput | PREMIOSWhereInput[]
    OR?: PREMIOSWhereInput[]
    NOT?: PREMIOSWhereInput | PREMIOSWhereInput[]
    descricao?: StringFilter<"PREMIOS"> | string
    valor?: DecimalFilter<"PREMIOS"> | Decimal | DecimalJsLike | number | string
    id_usuario?: IntNullableFilter<"PREMIOS"> | number | null
    id_jogo?: IntFilter<"PREMIOS"> | number
    JOGO?: XOR<JOGOScalarRelationFilter, JOGOWhereInput>
    USUARIO?: XOR<USUARIONullableScalarRelationFilter, USUARIOWhereInput> | null
  }, "id_premio">

  export type PREMIOSOrderByWithAggregationInput = {
    id_premio?: SortOrder
    descricao?: SortOrder
    valor?: SortOrder
    id_usuario?: SortOrderInput | SortOrder
    id_jogo?: SortOrder
    _count?: PREMIOSCountOrderByAggregateInput
    _avg?: PREMIOSAvgOrderByAggregateInput
    _max?: PREMIOSMaxOrderByAggregateInput
    _min?: PREMIOSMinOrderByAggregateInput
    _sum?: PREMIOSSumOrderByAggregateInput
  }

  export type PREMIOSScalarWhereWithAggregatesInput = {
    AND?: PREMIOSScalarWhereWithAggregatesInput | PREMIOSScalarWhereWithAggregatesInput[]
    OR?: PREMIOSScalarWhereWithAggregatesInput[]
    NOT?: PREMIOSScalarWhereWithAggregatesInput | PREMIOSScalarWhereWithAggregatesInput[]
    id_premio?: IntWithAggregatesFilter<"PREMIOS"> | number
    descricao?: StringWithAggregatesFilter<"PREMIOS"> | string
    valor?: DecimalWithAggregatesFilter<"PREMIOS"> | Decimal | DecimalJsLike | number | string
    id_usuario?: IntNullableWithAggregatesFilter<"PREMIOS"> | number | null
    id_jogo?: IntWithAggregatesFilter<"PREMIOS"> | number
  }

  export type SALAWhereInput = {
    AND?: SALAWhereInput | SALAWhereInput[]
    OR?: SALAWhereInput[]
    NOT?: SALAWhereInput | SALAWhereInput[]
    id_sala?: IntFilter<"SALA"> | number
    nome?: StringFilter<"SALA"> | string
    descricao?: StringNullableFilter<"SALA"> | string | null
    JOGO?: JOGOListRelationFilter
  }

  export type SALAOrderByWithRelationInput = {
    id_sala?: SortOrder
    nome?: SortOrder
    descricao?: SortOrderInput | SortOrder
    JOGO?: JOGOOrderByRelationAggregateInput
    _relevance?: SALAOrderByRelevanceInput
  }

  export type SALAWhereUniqueInput = Prisma.AtLeast<{
    id_sala?: number
    AND?: SALAWhereInput | SALAWhereInput[]
    OR?: SALAWhereInput[]
    NOT?: SALAWhereInput | SALAWhereInput[]
    nome?: StringFilter<"SALA"> | string
    descricao?: StringNullableFilter<"SALA"> | string | null
    JOGO?: JOGOListRelationFilter
  }, "id_sala">

  export type SALAOrderByWithAggregationInput = {
    id_sala?: SortOrder
    nome?: SortOrder
    descricao?: SortOrderInput | SortOrder
    _count?: SALACountOrderByAggregateInput
    _avg?: SALAAvgOrderByAggregateInput
    _max?: SALAMaxOrderByAggregateInput
    _min?: SALAMinOrderByAggregateInput
    _sum?: SALASumOrderByAggregateInput
  }

  export type SALAScalarWhereWithAggregatesInput = {
    AND?: SALAScalarWhereWithAggregatesInput | SALAScalarWhereWithAggregatesInput[]
    OR?: SALAScalarWhereWithAggregatesInput[]
    NOT?: SALAScalarWhereWithAggregatesInput | SALAScalarWhereWithAggregatesInput[]
    id_sala?: IntWithAggregatesFilter<"SALA"> | number
    nome?: StringWithAggregatesFilter<"SALA"> | string
    descricao?: StringNullableWithAggregatesFilter<"SALA"> | string | null
  }

  export type USUARIOWhereInput = {
    AND?: USUARIOWhereInput | USUARIOWhereInput[]
    OR?: USUARIOWhereInput[]
    NOT?: USUARIOWhereInput | USUARIOWhereInput[]
    id_usuario?: IntFilter<"USUARIO"> | number
    nome?: StringFilter<"USUARIO"> | string
    email?: StringFilter<"USUARIO"> | string
    senha?: StringFilter<"USUARIO"> | string
    creditos?: DecimalFilter<"USUARIO"> | Decimal | DecimalJsLike | number | string
    is_admin?: BoolFilter<"USUARIO"> | boolean
    CARTELA?: CARTELAListRelationFilter
    JOGO?: JOGOListRelationFilter
    PREMIOS?: PREMIOSListRelationFilter
  }

  export type USUARIOOrderByWithRelationInput = {
    id_usuario?: SortOrder
    nome?: SortOrder
    email?: SortOrder
    senha?: SortOrder
    creditos?: SortOrder
    is_admin?: SortOrder
    CARTELA?: CARTELAOrderByRelationAggregateInput
    JOGO?: JOGOOrderByRelationAggregateInput
    PREMIOS?: PREMIOSOrderByRelationAggregateInput
    _relevance?: USUARIOOrderByRelevanceInput
  }

  export type USUARIOWhereUniqueInput = Prisma.AtLeast<{
    id_usuario?: number
    email?: string
    AND?: USUARIOWhereInput | USUARIOWhereInput[]
    OR?: USUARIOWhereInput[]
    NOT?: USUARIOWhereInput | USUARIOWhereInput[]
    nome?: StringFilter<"USUARIO"> | string
    senha?: StringFilter<"USUARIO"> | string
    creditos?: DecimalFilter<"USUARIO"> | Decimal | DecimalJsLike | number | string
    is_admin?: BoolFilter<"USUARIO"> | boolean
    CARTELA?: CARTELAListRelationFilter
    JOGO?: JOGOListRelationFilter
    PREMIOS?: PREMIOSListRelationFilter
  }, "id_usuario" | "email">

  export type USUARIOOrderByWithAggregationInput = {
    id_usuario?: SortOrder
    nome?: SortOrder
    email?: SortOrder
    senha?: SortOrder
    creditos?: SortOrder
    is_admin?: SortOrder
    _count?: USUARIOCountOrderByAggregateInput
    _avg?: USUARIOAvgOrderByAggregateInput
    _max?: USUARIOMaxOrderByAggregateInput
    _min?: USUARIOMinOrderByAggregateInput
    _sum?: USUARIOSumOrderByAggregateInput
  }

  export type USUARIOScalarWhereWithAggregatesInput = {
    AND?: USUARIOScalarWhereWithAggregatesInput | USUARIOScalarWhereWithAggregatesInput[]
    OR?: USUARIOScalarWhereWithAggregatesInput[]
    NOT?: USUARIOScalarWhereWithAggregatesInput | USUARIOScalarWhereWithAggregatesInput[]
    id_usuario?: IntWithAggregatesFilter<"USUARIO"> | number
    nome?: StringWithAggregatesFilter<"USUARIO"> | string
    email?: StringWithAggregatesFilter<"USUARIO"> | string
    senha?: StringWithAggregatesFilter<"USUARIO"> | string
    creditos?: DecimalWithAggregatesFilter<"USUARIO"> | Decimal | DecimalJsLike | number | string
    is_admin?: BoolWithAggregatesFilter<"USUARIO"> | boolean
  }

  export type CARTELACreateInput = {
    JOGO: JOGOCreateNestedOneWithoutCARTELAInput
    USUARIO: USUARIOCreateNestedOneWithoutCARTELAInput
    NUMEROS_CARTELA?: NUMEROS_CARTELACreateNestedManyWithoutCARTELAInput
  }

  export type CARTELAUncheckedCreateInput = {
    id_cartela?: number
    id_usuario: number
    id_jogo: number
    NUMEROS_CARTELA?: NUMEROS_CARTELAUncheckedCreateNestedManyWithoutCARTELAInput
  }

  export type CARTELAUpdateInput = {
    JOGO?: JOGOUpdateOneRequiredWithoutCARTELANestedInput
    USUARIO?: USUARIOUpdateOneRequiredWithoutCARTELANestedInput
    NUMEROS_CARTELA?: NUMEROS_CARTELAUpdateManyWithoutCARTELANestedInput
  }

  export type CARTELAUncheckedUpdateInput = {
    id_cartela?: IntFieldUpdateOperationsInput | number
    id_usuario?: IntFieldUpdateOperationsInput | number
    id_jogo?: IntFieldUpdateOperationsInput | number
    NUMEROS_CARTELA?: NUMEROS_CARTELAUncheckedUpdateManyWithoutCARTELANestedInput
  }

  export type CARTELACreateManyInput = {
    id_cartela?: number
    id_usuario: number
    id_jogo: number
  }

  export type CARTELAUpdateManyMutationInput = {

  }

  export type CARTELAUncheckedUpdateManyInput = {
    id_cartela?: IntFieldUpdateOperationsInput | number
    id_usuario?: IntFieldUpdateOperationsInput | number
    id_jogo?: IntFieldUpdateOperationsInput | number
  }

  export type JOGOCreateInput = {
    data_hora: Date | string
    preco_cartela: Decimal | DecimalJsLike | number | string
    CARTELA?: CARTELACreateNestedManyWithoutJOGOInput
    SALA: SALACreateNestedOneWithoutJOGOInput
    USUARIO?: USUARIOCreateNestedOneWithoutJOGOInput
    NUMEROS_SORTEADOS?: NUMEROS_SORTEADOSCreateNestedManyWithoutJOGOInput
    PREMIOS?: PREMIOSCreateNestedManyWithoutJOGOInput
  }

  export type JOGOUncheckedCreateInput = {
    id_jogo?: number
    data_hora: Date | string
    id_sala: number
    id_usuario_vencedor?: number | null
    preco_cartela: Decimal | DecimalJsLike | number | string
    CARTELA?: CARTELAUncheckedCreateNestedManyWithoutJOGOInput
    NUMEROS_SORTEADOS?: NUMEROS_SORTEADOSUncheckedCreateNestedManyWithoutJOGOInput
    PREMIOS?: PREMIOSUncheckedCreateNestedManyWithoutJOGOInput
  }

  export type JOGOUpdateInput = {
    data_hora?: DateTimeFieldUpdateOperationsInput | Date | string
    preco_cartela?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    CARTELA?: CARTELAUpdateManyWithoutJOGONestedInput
    SALA?: SALAUpdateOneRequiredWithoutJOGONestedInput
    USUARIO?: USUARIOUpdateOneWithoutJOGONestedInput
    NUMEROS_SORTEADOS?: NUMEROS_SORTEADOSUpdateManyWithoutJOGONestedInput
    PREMIOS?: PREMIOSUpdateManyWithoutJOGONestedInput
  }

  export type JOGOUncheckedUpdateInput = {
    id_jogo?: IntFieldUpdateOperationsInput | number
    data_hora?: DateTimeFieldUpdateOperationsInput | Date | string
    id_sala?: IntFieldUpdateOperationsInput | number
    id_usuario_vencedor?: NullableIntFieldUpdateOperationsInput | number | null
    preco_cartela?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    CARTELA?: CARTELAUncheckedUpdateManyWithoutJOGONestedInput
    NUMEROS_SORTEADOS?: NUMEROS_SORTEADOSUncheckedUpdateManyWithoutJOGONestedInput
    PREMIOS?: PREMIOSUncheckedUpdateManyWithoutJOGONestedInput
  }

  export type JOGOCreateManyInput = {
    id_jogo?: number
    data_hora: Date | string
    id_sala: number
    id_usuario_vencedor?: number | null
    preco_cartela: Decimal | DecimalJsLike | number | string
  }

  export type JOGOUpdateManyMutationInput = {
    data_hora?: DateTimeFieldUpdateOperationsInput | Date | string
    preco_cartela?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type JOGOUncheckedUpdateManyInput = {
    id_jogo?: IntFieldUpdateOperationsInput | number
    data_hora?: DateTimeFieldUpdateOperationsInput | Date | string
    id_sala?: IntFieldUpdateOperationsInput | number
    id_usuario_vencedor?: NullableIntFieldUpdateOperationsInput | number | null
    preco_cartela?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type NUMEROS_CARTELACreateInput = {
    numero: number
    CARTELA: CARTELACreateNestedOneWithoutNUMEROS_CARTELAInput
  }

  export type NUMEROS_CARTELAUncheckedCreateInput = {
    id_numero_cartela?: number
    numero: number
    id_cartela: number
  }

  export type NUMEROS_CARTELAUpdateInput = {
    numero?: IntFieldUpdateOperationsInput | number
    CARTELA?: CARTELAUpdateOneRequiredWithoutNUMEROS_CARTELANestedInput
  }

  export type NUMEROS_CARTELAUncheckedUpdateInput = {
    id_numero_cartela?: IntFieldUpdateOperationsInput | number
    numero?: IntFieldUpdateOperationsInput | number
    id_cartela?: IntFieldUpdateOperationsInput | number
  }

  export type NUMEROS_CARTELACreateManyInput = {
    id_numero_cartela?: number
    numero: number
    id_cartela: number
  }

  export type NUMEROS_CARTELAUpdateManyMutationInput = {
    numero?: IntFieldUpdateOperationsInput | number
  }

  export type NUMEROS_CARTELAUncheckedUpdateManyInput = {
    id_numero_cartela?: IntFieldUpdateOperationsInput | number
    numero?: IntFieldUpdateOperationsInput | number
    id_cartela?: IntFieldUpdateOperationsInput | number
  }

  export type NUMEROS_SORTEADOSCreateInput = {
    numero: number
    ordem_sorteio: number
    JOGO: JOGOCreateNestedOneWithoutNUMEROS_SORTEADOSInput
  }

  export type NUMEROS_SORTEADOSUncheckedCreateInput = {
    id_numero_sorteado?: number
    numero: number
    ordem_sorteio: number
    id_jogo: number
  }

  export type NUMEROS_SORTEADOSUpdateInput = {
    numero?: IntFieldUpdateOperationsInput | number
    ordem_sorteio?: IntFieldUpdateOperationsInput | number
    JOGO?: JOGOUpdateOneRequiredWithoutNUMEROS_SORTEADOSNestedInput
  }

  export type NUMEROS_SORTEADOSUncheckedUpdateInput = {
    id_numero_sorteado?: IntFieldUpdateOperationsInput | number
    numero?: IntFieldUpdateOperationsInput | number
    ordem_sorteio?: IntFieldUpdateOperationsInput | number
    id_jogo?: IntFieldUpdateOperationsInput | number
  }

  export type NUMEROS_SORTEADOSCreateManyInput = {
    id_numero_sorteado?: number
    numero: number
    ordem_sorteio: number
    id_jogo: number
  }

  export type NUMEROS_SORTEADOSUpdateManyMutationInput = {
    numero?: IntFieldUpdateOperationsInput | number
    ordem_sorteio?: IntFieldUpdateOperationsInput | number
  }

  export type NUMEROS_SORTEADOSUncheckedUpdateManyInput = {
    id_numero_sorteado?: IntFieldUpdateOperationsInput | number
    numero?: IntFieldUpdateOperationsInput | number
    ordem_sorteio?: IntFieldUpdateOperationsInput | number
    id_jogo?: IntFieldUpdateOperationsInput | number
  }

  export type PREMIOSCreateInput = {
    descricao: string
    valor: Decimal | DecimalJsLike | number | string
    JOGO: JOGOCreateNestedOneWithoutPREMIOSInput
    USUARIO?: USUARIOCreateNestedOneWithoutPREMIOSInput
  }

  export type PREMIOSUncheckedCreateInput = {
    id_premio?: number
    descricao: string
    valor: Decimal | DecimalJsLike | number | string
    id_usuario?: number | null
    id_jogo: number
  }

  export type PREMIOSUpdateInput = {
    descricao?: StringFieldUpdateOperationsInput | string
    valor?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    JOGO?: JOGOUpdateOneRequiredWithoutPREMIOSNestedInput
    USUARIO?: USUARIOUpdateOneWithoutPREMIOSNestedInput
  }

  export type PREMIOSUncheckedUpdateInput = {
    id_premio?: IntFieldUpdateOperationsInput | number
    descricao?: StringFieldUpdateOperationsInput | string
    valor?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    id_usuario?: NullableIntFieldUpdateOperationsInput | number | null
    id_jogo?: IntFieldUpdateOperationsInput | number
  }

  export type PREMIOSCreateManyInput = {
    id_premio?: number
    descricao: string
    valor: Decimal | DecimalJsLike | number | string
    id_usuario?: number | null
    id_jogo: number
  }

  export type PREMIOSUpdateManyMutationInput = {
    descricao?: StringFieldUpdateOperationsInput | string
    valor?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type PREMIOSUncheckedUpdateManyInput = {
    id_premio?: IntFieldUpdateOperationsInput | number
    descricao?: StringFieldUpdateOperationsInput | string
    valor?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    id_usuario?: NullableIntFieldUpdateOperationsInput | number | null
    id_jogo?: IntFieldUpdateOperationsInput | number
  }

  export type SALACreateInput = {
    nome: string
    descricao?: string | null
    JOGO?: JOGOCreateNestedManyWithoutSALAInput
  }

  export type SALAUncheckedCreateInput = {
    id_sala?: number
    nome: string
    descricao?: string | null
    JOGO?: JOGOUncheckedCreateNestedManyWithoutSALAInput
  }

  export type SALAUpdateInput = {
    nome?: StringFieldUpdateOperationsInput | string
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
    JOGO?: JOGOUpdateManyWithoutSALANestedInput
  }

  export type SALAUncheckedUpdateInput = {
    id_sala?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
    JOGO?: JOGOUncheckedUpdateManyWithoutSALANestedInput
  }

  export type SALACreateManyInput = {
    id_sala?: number
    nome: string
    descricao?: string | null
  }

  export type SALAUpdateManyMutationInput = {
    nome?: StringFieldUpdateOperationsInput | string
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SALAUncheckedUpdateManyInput = {
    id_sala?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type USUARIOCreateInput = {
    nome: string
    email: string
    senha: string
    creditos: Decimal | DecimalJsLike | number | string
    is_admin?: boolean
    CARTELA?: CARTELACreateNestedManyWithoutUSUARIOInput
    JOGO?: JOGOCreateNestedManyWithoutUSUARIOInput
    PREMIOS?: PREMIOSCreateNestedManyWithoutUSUARIOInput
  }

  export type USUARIOUncheckedCreateInput = {
    id_usuario?: number
    nome: string
    email: string
    senha: string
    creditos: Decimal | DecimalJsLike | number | string
    is_admin?: boolean
    CARTELA?: CARTELAUncheckedCreateNestedManyWithoutUSUARIOInput
    JOGO?: JOGOUncheckedCreateNestedManyWithoutUSUARIOInput
    PREMIOS?: PREMIOSUncheckedCreateNestedManyWithoutUSUARIOInput
  }

  export type USUARIOUpdateInput = {
    nome?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    creditos?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    is_admin?: BoolFieldUpdateOperationsInput | boolean
    CARTELA?: CARTELAUpdateManyWithoutUSUARIONestedInput
    JOGO?: JOGOUpdateManyWithoutUSUARIONestedInput
    PREMIOS?: PREMIOSUpdateManyWithoutUSUARIONestedInput
  }

  export type USUARIOUncheckedUpdateInput = {
    id_usuario?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    creditos?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    is_admin?: BoolFieldUpdateOperationsInput | boolean
    CARTELA?: CARTELAUncheckedUpdateManyWithoutUSUARIONestedInput
    JOGO?: JOGOUncheckedUpdateManyWithoutUSUARIONestedInput
    PREMIOS?: PREMIOSUncheckedUpdateManyWithoutUSUARIONestedInput
  }

  export type USUARIOCreateManyInput = {
    id_usuario?: number
    nome: string
    email: string
    senha: string
    creditos: Decimal | DecimalJsLike | number | string
    is_admin?: boolean
  }

  export type USUARIOUpdateManyMutationInput = {
    nome?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    creditos?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    is_admin?: BoolFieldUpdateOperationsInput | boolean
  }

  export type USUARIOUncheckedUpdateManyInput = {
    id_usuario?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    creditos?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    is_admin?: BoolFieldUpdateOperationsInput | boolean
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type JOGOScalarRelationFilter = {
    is?: JOGOWhereInput
    isNot?: JOGOWhereInput
  }

  export type USUARIOScalarRelationFilter = {
    is?: USUARIOWhereInput
    isNot?: USUARIOWhereInput
  }

  export type NUMEROS_CARTELAListRelationFilter = {
    every?: NUMEROS_CARTELAWhereInput
    some?: NUMEROS_CARTELAWhereInput
    none?: NUMEROS_CARTELAWhereInput
  }

  export type NUMEROS_CARTELAOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CARTELACountOrderByAggregateInput = {
    id_cartela?: SortOrder
    id_usuario?: SortOrder
    id_jogo?: SortOrder
  }

  export type CARTELAAvgOrderByAggregateInput = {
    id_cartela?: SortOrder
    id_usuario?: SortOrder
    id_jogo?: SortOrder
  }

  export type CARTELAMaxOrderByAggregateInput = {
    id_cartela?: SortOrder
    id_usuario?: SortOrder
    id_jogo?: SortOrder
  }

  export type CARTELAMinOrderByAggregateInput = {
    id_cartela?: SortOrder
    id_usuario?: SortOrder
    id_jogo?: SortOrder
  }

  export type CARTELASumOrderByAggregateInput = {
    id_cartela?: SortOrder
    id_usuario?: SortOrder
    id_jogo?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type CARTELAListRelationFilter = {
    every?: CARTELAWhereInput
    some?: CARTELAWhereInput
    none?: CARTELAWhereInput
  }

  export type SALAScalarRelationFilter = {
    is?: SALAWhereInput
    isNot?: SALAWhereInput
  }

  export type USUARIONullableScalarRelationFilter = {
    is?: USUARIOWhereInput | null
    isNot?: USUARIOWhereInput | null
  }

  export type NUMEROS_SORTEADOSListRelationFilter = {
    every?: NUMEROS_SORTEADOSWhereInput
    some?: NUMEROS_SORTEADOSWhereInput
    none?: NUMEROS_SORTEADOSWhereInput
  }

  export type PREMIOSListRelationFilter = {
    every?: PREMIOSWhereInput
    some?: PREMIOSWhereInput
    none?: PREMIOSWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type CARTELAOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NUMEROS_SORTEADOSOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PREMIOSOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type JOGOCountOrderByAggregateInput = {
    id_jogo?: SortOrder
    data_hora?: SortOrder
    id_sala?: SortOrder
    id_usuario_vencedor?: SortOrder
    preco_cartela?: SortOrder
  }

  export type JOGOAvgOrderByAggregateInput = {
    id_jogo?: SortOrder
    id_sala?: SortOrder
    id_usuario_vencedor?: SortOrder
    preco_cartela?: SortOrder
  }

  export type JOGOMaxOrderByAggregateInput = {
    id_jogo?: SortOrder
    data_hora?: SortOrder
    id_sala?: SortOrder
    id_usuario_vencedor?: SortOrder
    preco_cartela?: SortOrder
  }

  export type JOGOMinOrderByAggregateInput = {
    id_jogo?: SortOrder
    data_hora?: SortOrder
    id_sala?: SortOrder
    id_usuario_vencedor?: SortOrder
    preco_cartela?: SortOrder
  }

  export type JOGOSumOrderByAggregateInput = {
    id_jogo?: SortOrder
    id_sala?: SortOrder
    id_usuario_vencedor?: SortOrder
    preco_cartela?: SortOrder
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type CARTELAScalarRelationFilter = {
    is?: CARTELAWhereInput
    isNot?: CARTELAWhereInput
  }

  export type NUMEROS_CARTELACountOrderByAggregateInput = {
    id_numero_cartela?: SortOrder
    numero?: SortOrder
    id_cartela?: SortOrder
  }

  export type NUMEROS_CARTELAAvgOrderByAggregateInput = {
    id_numero_cartela?: SortOrder
    numero?: SortOrder
    id_cartela?: SortOrder
  }

  export type NUMEROS_CARTELAMaxOrderByAggregateInput = {
    id_numero_cartela?: SortOrder
    numero?: SortOrder
    id_cartela?: SortOrder
  }

  export type NUMEROS_CARTELAMinOrderByAggregateInput = {
    id_numero_cartela?: SortOrder
    numero?: SortOrder
    id_cartela?: SortOrder
  }

  export type NUMEROS_CARTELASumOrderByAggregateInput = {
    id_numero_cartela?: SortOrder
    numero?: SortOrder
    id_cartela?: SortOrder
  }

  export type NUMEROS_SORTEADOSCountOrderByAggregateInput = {
    id_numero_sorteado?: SortOrder
    numero?: SortOrder
    ordem_sorteio?: SortOrder
    id_jogo?: SortOrder
  }

  export type NUMEROS_SORTEADOSAvgOrderByAggregateInput = {
    id_numero_sorteado?: SortOrder
    numero?: SortOrder
    ordem_sorteio?: SortOrder
    id_jogo?: SortOrder
  }

  export type NUMEROS_SORTEADOSMaxOrderByAggregateInput = {
    id_numero_sorteado?: SortOrder
    numero?: SortOrder
    ordem_sorteio?: SortOrder
    id_jogo?: SortOrder
  }

  export type NUMEROS_SORTEADOSMinOrderByAggregateInput = {
    id_numero_sorteado?: SortOrder
    numero?: SortOrder
    ordem_sorteio?: SortOrder
    id_jogo?: SortOrder
  }

  export type NUMEROS_SORTEADOSSumOrderByAggregateInput = {
    id_numero_sorteado?: SortOrder
    numero?: SortOrder
    ordem_sorteio?: SortOrder
    id_jogo?: SortOrder
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type PREMIOSOrderByRelevanceInput = {
    fields: PREMIOSOrderByRelevanceFieldEnum | PREMIOSOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type PREMIOSCountOrderByAggregateInput = {
    id_premio?: SortOrder
    descricao?: SortOrder
    valor?: SortOrder
    id_usuario?: SortOrder
    id_jogo?: SortOrder
  }

  export type PREMIOSAvgOrderByAggregateInput = {
    id_premio?: SortOrder
    valor?: SortOrder
    id_usuario?: SortOrder
    id_jogo?: SortOrder
  }

  export type PREMIOSMaxOrderByAggregateInput = {
    id_premio?: SortOrder
    descricao?: SortOrder
    valor?: SortOrder
    id_usuario?: SortOrder
    id_jogo?: SortOrder
  }

  export type PREMIOSMinOrderByAggregateInput = {
    id_premio?: SortOrder
    descricao?: SortOrder
    valor?: SortOrder
    id_usuario?: SortOrder
    id_jogo?: SortOrder
  }

  export type PREMIOSSumOrderByAggregateInput = {
    id_premio?: SortOrder
    valor?: SortOrder
    id_usuario?: SortOrder
    id_jogo?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type JOGOListRelationFilter = {
    every?: JOGOWhereInput
    some?: JOGOWhereInput
    none?: JOGOWhereInput
  }

  export type JOGOOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SALAOrderByRelevanceInput = {
    fields: SALAOrderByRelevanceFieldEnum | SALAOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type SALACountOrderByAggregateInput = {
    id_sala?: SortOrder
    nome?: SortOrder
    descricao?: SortOrder
  }

  export type SALAAvgOrderByAggregateInput = {
    id_sala?: SortOrder
  }

  export type SALAMaxOrderByAggregateInput = {
    id_sala?: SortOrder
    nome?: SortOrder
    descricao?: SortOrder
  }

  export type SALAMinOrderByAggregateInput = {
    id_sala?: SortOrder
    nome?: SortOrder
    descricao?: SortOrder
  }

  export type SALASumOrderByAggregateInput = {
    id_sala?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type USUARIOOrderByRelevanceInput = {
    fields: USUARIOOrderByRelevanceFieldEnum | USUARIOOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type USUARIOCountOrderByAggregateInput = {
    id_usuario?: SortOrder
    nome?: SortOrder
    email?: SortOrder
    senha?: SortOrder
    creditos?: SortOrder
    is_admin?: SortOrder
  }

  export type USUARIOAvgOrderByAggregateInput = {
    id_usuario?: SortOrder
    creditos?: SortOrder
  }

  export type USUARIOMaxOrderByAggregateInput = {
    id_usuario?: SortOrder
    nome?: SortOrder
    email?: SortOrder
    senha?: SortOrder
    creditos?: SortOrder
    is_admin?: SortOrder
  }

  export type USUARIOMinOrderByAggregateInput = {
    id_usuario?: SortOrder
    nome?: SortOrder
    email?: SortOrder
    senha?: SortOrder
    creditos?: SortOrder
    is_admin?: SortOrder
  }

  export type USUARIOSumOrderByAggregateInput = {
    id_usuario?: SortOrder
    creditos?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type JOGOCreateNestedOneWithoutCARTELAInput = {
    create?: XOR<JOGOCreateWithoutCARTELAInput, JOGOUncheckedCreateWithoutCARTELAInput>
    connectOrCreate?: JOGOCreateOrConnectWithoutCARTELAInput
    connect?: JOGOWhereUniqueInput
  }

  export type USUARIOCreateNestedOneWithoutCARTELAInput = {
    create?: XOR<USUARIOCreateWithoutCARTELAInput, USUARIOUncheckedCreateWithoutCARTELAInput>
    connectOrCreate?: USUARIOCreateOrConnectWithoutCARTELAInput
    connect?: USUARIOWhereUniqueInput
  }

  export type NUMEROS_CARTELACreateNestedManyWithoutCARTELAInput = {
    create?: XOR<NUMEROS_CARTELACreateWithoutCARTELAInput, NUMEROS_CARTELAUncheckedCreateWithoutCARTELAInput> | NUMEROS_CARTELACreateWithoutCARTELAInput[] | NUMEROS_CARTELAUncheckedCreateWithoutCARTELAInput[]
    connectOrCreate?: NUMEROS_CARTELACreateOrConnectWithoutCARTELAInput | NUMEROS_CARTELACreateOrConnectWithoutCARTELAInput[]
    createMany?: NUMEROS_CARTELACreateManyCARTELAInputEnvelope
    connect?: NUMEROS_CARTELAWhereUniqueInput | NUMEROS_CARTELAWhereUniqueInput[]
  }

  export type NUMEROS_CARTELAUncheckedCreateNestedManyWithoutCARTELAInput = {
    create?: XOR<NUMEROS_CARTELACreateWithoutCARTELAInput, NUMEROS_CARTELAUncheckedCreateWithoutCARTELAInput> | NUMEROS_CARTELACreateWithoutCARTELAInput[] | NUMEROS_CARTELAUncheckedCreateWithoutCARTELAInput[]
    connectOrCreate?: NUMEROS_CARTELACreateOrConnectWithoutCARTELAInput | NUMEROS_CARTELACreateOrConnectWithoutCARTELAInput[]
    createMany?: NUMEROS_CARTELACreateManyCARTELAInputEnvelope
    connect?: NUMEROS_CARTELAWhereUniqueInput | NUMEROS_CARTELAWhereUniqueInput[]
  }

  export type JOGOUpdateOneRequiredWithoutCARTELANestedInput = {
    create?: XOR<JOGOCreateWithoutCARTELAInput, JOGOUncheckedCreateWithoutCARTELAInput>
    connectOrCreate?: JOGOCreateOrConnectWithoutCARTELAInput
    upsert?: JOGOUpsertWithoutCARTELAInput
    connect?: JOGOWhereUniqueInput
    update?: XOR<XOR<JOGOUpdateToOneWithWhereWithoutCARTELAInput, JOGOUpdateWithoutCARTELAInput>, JOGOUncheckedUpdateWithoutCARTELAInput>
  }

  export type USUARIOUpdateOneRequiredWithoutCARTELANestedInput = {
    create?: XOR<USUARIOCreateWithoutCARTELAInput, USUARIOUncheckedCreateWithoutCARTELAInput>
    connectOrCreate?: USUARIOCreateOrConnectWithoutCARTELAInput
    upsert?: USUARIOUpsertWithoutCARTELAInput
    connect?: USUARIOWhereUniqueInput
    update?: XOR<XOR<USUARIOUpdateToOneWithWhereWithoutCARTELAInput, USUARIOUpdateWithoutCARTELAInput>, USUARIOUncheckedUpdateWithoutCARTELAInput>
  }

  export type NUMEROS_CARTELAUpdateManyWithoutCARTELANestedInput = {
    create?: XOR<NUMEROS_CARTELACreateWithoutCARTELAInput, NUMEROS_CARTELAUncheckedCreateWithoutCARTELAInput> | NUMEROS_CARTELACreateWithoutCARTELAInput[] | NUMEROS_CARTELAUncheckedCreateWithoutCARTELAInput[]
    connectOrCreate?: NUMEROS_CARTELACreateOrConnectWithoutCARTELAInput | NUMEROS_CARTELACreateOrConnectWithoutCARTELAInput[]
    upsert?: NUMEROS_CARTELAUpsertWithWhereUniqueWithoutCARTELAInput | NUMEROS_CARTELAUpsertWithWhereUniqueWithoutCARTELAInput[]
    createMany?: NUMEROS_CARTELACreateManyCARTELAInputEnvelope
    set?: NUMEROS_CARTELAWhereUniqueInput | NUMEROS_CARTELAWhereUniqueInput[]
    disconnect?: NUMEROS_CARTELAWhereUniqueInput | NUMEROS_CARTELAWhereUniqueInput[]
    delete?: NUMEROS_CARTELAWhereUniqueInput | NUMEROS_CARTELAWhereUniqueInput[]
    connect?: NUMEROS_CARTELAWhereUniqueInput | NUMEROS_CARTELAWhereUniqueInput[]
    update?: NUMEROS_CARTELAUpdateWithWhereUniqueWithoutCARTELAInput | NUMEROS_CARTELAUpdateWithWhereUniqueWithoutCARTELAInput[]
    updateMany?: NUMEROS_CARTELAUpdateManyWithWhereWithoutCARTELAInput | NUMEROS_CARTELAUpdateManyWithWhereWithoutCARTELAInput[]
    deleteMany?: NUMEROS_CARTELAScalarWhereInput | NUMEROS_CARTELAScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NUMEROS_CARTELAUncheckedUpdateManyWithoutCARTELANestedInput = {
    create?: XOR<NUMEROS_CARTELACreateWithoutCARTELAInput, NUMEROS_CARTELAUncheckedCreateWithoutCARTELAInput> | NUMEROS_CARTELACreateWithoutCARTELAInput[] | NUMEROS_CARTELAUncheckedCreateWithoutCARTELAInput[]
    connectOrCreate?: NUMEROS_CARTELACreateOrConnectWithoutCARTELAInput | NUMEROS_CARTELACreateOrConnectWithoutCARTELAInput[]
    upsert?: NUMEROS_CARTELAUpsertWithWhereUniqueWithoutCARTELAInput | NUMEROS_CARTELAUpsertWithWhereUniqueWithoutCARTELAInput[]
    createMany?: NUMEROS_CARTELACreateManyCARTELAInputEnvelope
    set?: NUMEROS_CARTELAWhereUniqueInput | NUMEROS_CARTELAWhereUniqueInput[]
    disconnect?: NUMEROS_CARTELAWhereUniqueInput | NUMEROS_CARTELAWhereUniqueInput[]
    delete?: NUMEROS_CARTELAWhereUniqueInput | NUMEROS_CARTELAWhereUniqueInput[]
    connect?: NUMEROS_CARTELAWhereUniqueInput | NUMEROS_CARTELAWhereUniqueInput[]
    update?: NUMEROS_CARTELAUpdateWithWhereUniqueWithoutCARTELAInput | NUMEROS_CARTELAUpdateWithWhereUniqueWithoutCARTELAInput[]
    updateMany?: NUMEROS_CARTELAUpdateManyWithWhereWithoutCARTELAInput | NUMEROS_CARTELAUpdateManyWithWhereWithoutCARTELAInput[]
    deleteMany?: NUMEROS_CARTELAScalarWhereInput | NUMEROS_CARTELAScalarWhereInput[]
  }

  export type CARTELACreateNestedManyWithoutJOGOInput = {
    create?: XOR<CARTELACreateWithoutJOGOInput, CARTELAUncheckedCreateWithoutJOGOInput> | CARTELACreateWithoutJOGOInput[] | CARTELAUncheckedCreateWithoutJOGOInput[]
    connectOrCreate?: CARTELACreateOrConnectWithoutJOGOInput | CARTELACreateOrConnectWithoutJOGOInput[]
    createMany?: CARTELACreateManyJOGOInputEnvelope
    connect?: CARTELAWhereUniqueInput | CARTELAWhereUniqueInput[]
  }

  export type SALACreateNestedOneWithoutJOGOInput = {
    create?: XOR<SALACreateWithoutJOGOInput, SALAUncheckedCreateWithoutJOGOInput>
    connectOrCreate?: SALACreateOrConnectWithoutJOGOInput
    connect?: SALAWhereUniqueInput
  }

  export type USUARIOCreateNestedOneWithoutJOGOInput = {
    create?: XOR<USUARIOCreateWithoutJOGOInput, USUARIOUncheckedCreateWithoutJOGOInput>
    connectOrCreate?: USUARIOCreateOrConnectWithoutJOGOInput
    connect?: USUARIOWhereUniqueInput
  }

  export type NUMEROS_SORTEADOSCreateNestedManyWithoutJOGOInput = {
    create?: XOR<NUMEROS_SORTEADOSCreateWithoutJOGOInput, NUMEROS_SORTEADOSUncheckedCreateWithoutJOGOInput> | NUMEROS_SORTEADOSCreateWithoutJOGOInput[] | NUMEROS_SORTEADOSUncheckedCreateWithoutJOGOInput[]
    connectOrCreate?: NUMEROS_SORTEADOSCreateOrConnectWithoutJOGOInput | NUMEROS_SORTEADOSCreateOrConnectWithoutJOGOInput[]
    createMany?: NUMEROS_SORTEADOSCreateManyJOGOInputEnvelope
    connect?: NUMEROS_SORTEADOSWhereUniqueInput | NUMEROS_SORTEADOSWhereUniqueInput[]
  }

  export type PREMIOSCreateNestedManyWithoutJOGOInput = {
    create?: XOR<PREMIOSCreateWithoutJOGOInput, PREMIOSUncheckedCreateWithoutJOGOInput> | PREMIOSCreateWithoutJOGOInput[] | PREMIOSUncheckedCreateWithoutJOGOInput[]
    connectOrCreate?: PREMIOSCreateOrConnectWithoutJOGOInput | PREMIOSCreateOrConnectWithoutJOGOInput[]
    createMany?: PREMIOSCreateManyJOGOInputEnvelope
    connect?: PREMIOSWhereUniqueInput | PREMIOSWhereUniqueInput[]
  }

  export type CARTELAUncheckedCreateNestedManyWithoutJOGOInput = {
    create?: XOR<CARTELACreateWithoutJOGOInput, CARTELAUncheckedCreateWithoutJOGOInput> | CARTELACreateWithoutJOGOInput[] | CARTELAUncheckedCreateWithoutJOGOInput[]
    connectOrCreate?: CARTELACreateOrConnectWithoutJOGOInput | CARTELACreateOrConnectWithoutJOGOInput[]
    createMany?: CARTELACreateManyJOGOInputEnvelope
    connect?: CARTELAWhereUniqueInput | CARTELAWhereUniqueInput[]
  }

  export type NUMEROS_SORTEADOSUncheckedCreateNestedManyWithoutJOGOInput = {
    create?: XOR<NUMEROS_SORTEADOSCreateWithoutJOGOInput, NUMEROS_SORTEADOSUncheckedCreateWithoutJOGOInput> | NUMEROS_SORTEADOSCreateWithoutJOGOInput[] | NUMEROS_SORTEADOSUncheckedCreateWithoutJOGOInput[]
    connectOrCreate?: NUMEROS_SORTEADOSCreateOrConnectWithoutJOGOInput | NUMEROS_SORTEADOSCreateOrConnectWithoutJOGOInput[]
    createMany?: NUMEROS_SORTEADOSCreateManyJOGOInputEnvelope
    connect?: NUMEROS_SORTEADOSWhereUniqueInput | NUMEROS_SORTEADOSWhereUniqueInput[]
  }

  export type PREMIOSUncheckedCreateNestedManyWithoutJOGOInput = {
    create?: XOR<PREMIOSCreateWithoutJOGOInput, PREMIOSUncheckedCreateWithoutJOGOInput> | PREMIOSCreateWithoutJOGOInput[] | PREMIOSUncheckedCreateWithoutJOGOInput[]
    connectOrCreate?: PREMIOSCreateOrConnectWithoutJOGOInput | PREMIOSCreateOrConnectWithoutJOGOInput[]
    createMany?: PREMIOSCreateManyJOGOInputEnvelope
    connect?: PREMIOSWhereUniqueInput | PREMIOSWhereUniqueInput[]
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type CARTELAUpdateManyWithoutJOGONestedInput = {
    create?: XOR<CARTELACreateWithoutJOGOInput, CARTELAUncheckedCreateWithoutJOGOInput> | CARTELACreateWithoutJOGOInput[] | CARTELAUncheckedCreateWithoutJOGOInput[]
    connectOrCreate?: CARTELACreateOrConnectWithoutJOGOInput | CARTELACreateOrConnectWithoutJOGOInput[]
    upsert?: CARTELAUpsertWithWhereUniqueWithoutJOGOInput | CARTELAUpsertWithWhereUniqueWithoutJOGOInput[]
    createMany?: CARTELACreateManyJOGOInputEnvelope
    set?: CARTELAWhereUniqueInput | CARTELAWhereUniqueInput[]
    disconnect?: CARTELAWhereUniqueInput | CARTELAWhereUniqueInput[]
    delete?: CARTELAWhereUniqueInput | CARTELAWhereUniqueInput[]
    connect?: CARTELAWhereUniqueInput | CARTELAWhereUniqueInput[]
    update?: CARTELAUpdateWithWhereUniqueWithoutJOGOInput | CARTELAUpdateWithWhereUniqueWithoutJOGOInput[]
    updateMany?: CARTELAUpdateManyWithWhereWithoutJOGOInput | CARTELAUpdateManyWithWhereWithoutJOGOInput[]
    deleteMany?: CARTELAScalarWhereInput | CARTELAScalarWhereInput[]
  }

  export type SALAUpdateOneRequiredWithoutJOGONestedInput = {
    create?: XOR<SALACreateWithoutJOGOInput, SALAUncheckedCreateWithoutJOGOInput>
    connectOrCreate?: SALACreateOrConnectWithoutJOGOInput
    upsert?: SALAUpsertWithoutJOGOInput
    connect?: SALAWhereUniqueInput
    update?: XOR<XOR<SALAUpdateToOneWithWhereWithoutJOGOInput, SALAUpdateWithoutJOGOInput>, SALAUncheckedUpdateWithoutJOGOInput>
  }

  export type USUARIOUpdateOneWithoutJOGONestedInput = {
    create?: XOR<USUARIOCreateWithoutJOGOInput, USUARIOUncheckedCreateWithoutJOGOInput>
    connectOrCreate?: USUARIOCreateOrConnectWithoutJOGOInput
    upsert?: USUARIOUpsertWithoutJOGOInput
    disconnect?: USUARIOWhereInput | boolean
    delete?: USUARIOWhereInput | boolean
    connect?: USUARIOWhereUniqueInput
    update?: XOR<XOR<USUARIOUpdateToOneWithWhereWithoutJOGOInput, USUARIOUpdateWithoutJOGOInput>, USUARIOUncheckedUpdateWithoutJOGOInput>
  }

  export type NUMEROS_SORTEADOSUpdateManyWithoutJOGONestedInput = {
    create?: XOR<NUMEROS_SORTEADOSCreateWithoutJOGOInput, NUMEROS_SORTEADOSUncheckedCreateWithoutJOGOInput> | NUMEROS_SORTEADOSCreateWithoutJOGOInput[] | NUMEROS_SORTEADOSUncheckedCreateWithoutJOGOInput[]
    connectOrCreate?: NUMEROS_SORTEADOSCreateOrConnectWithoutJOGOInput | NUMEROS_SORTEADOSCreateOrConnectWithoutJOGOInput[]
    upsert?: NUMEROS_SORTEADOSUpsertWithWhereUniqueWithoutJOGOInput | NUMEROS_SORTEADOSUpsertWithWhereUniqueWithoutJOGOInput[]
    createMany?: NUMEROS_SORTEADOSCreateManyJOGOInputEnvelope
    set?: NUMEROS_SORTEADOSWhereUniqueInput | NUMEROS_SORTEADOSWhereUniqueInput[]
    disconnect?: NUMEROS_SORTEADOSWhereUniqueInput | NUMEROS_SORTEADOSWhereUniqueInput[]
    delete?: NUMEROS_SORTEADOSWhereUniqueInput | NUMEROS_SORTEADOSWhereUniqueInput[]
    connect?: NUMEROS_SORTEADOSWhereUniqueInput | NUMEROS_SORTEADOSWhereUniqueInput[]
    update?: NUMEROS_SORTEADOSUpdateWithWhereUniqueWithoutJOGOInput | NUMEROS_SORTEADOSUpdateWithWhereUniqueWithoutJOGOInput[]
    updateMany?: NUMEROS_SORTEADOSUpdateManyWithWhereWithoutJOGOInput | NUMEROS_SORTEADOSUpdateManyWithWhereWithoutJOGOInput[]
    deleteMany?: NUMEROS_SORTEADOSScalarWhereInput | NUMEROS_SORTEADOSScalarWhereInput[]
  }

  export type PREMIOSUpdateManyWithoutJOGONestedInput = {
    create?: XOR<PREMIOSCreateWithoutJOGOInput, PREMIOSUncheckedCreateWithoutJOGOInput> | PREMIOSCreateWithoutJOGOInput[] | PREMIOSUncheckedCreateWithoutJOGOInput[]
    connectOrCreate?: PREMIOSCreateOrConnectWithoutJOGOInput | PREMIOSCreateOrConnectWithoutJOGOInput[]
    upsert?: PREMIOSUpsertWithWhereUniqueWithoutJOGOInput | PREMIOSUpsertWithWhereUniqueWithoutJOGOInput[]
    createMany?: PREMIOSCreateManyJOGOInputEnvelope
    set?: PREMIOSWhereUniqueInput | PREMIOSWhereUniqueInput[]
    disconnect?: PREMIOSWhereUniqueInput | PREMIOSWhereUniqueInput[]
    delete?: PREMIOSWhereUniqueInput | PREMIOSWhereUniqueInput[]
    connect?: PREMIOSWhereUniqueInput | PREMIOSWhereUniqueInput[]
    update?: PREMIOSUpdateWithWhereUniqueWithoutJOGOInput | PREMIOSUpdateWithWhereUniqueWithoutJOGOInput[]
    updateMany?: PREMIOSUpdateManyWithWhereWithoutJOGOInput | PREMIOSUpdateManyWithWhereWithoutJOGOInput[]
    deleteMany?: PREMIOSScalarWhereInput | PREMIOSScalarWhereInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type CARTELAUncheckedUpdateManyWithoutJOGONestedInput = {
    create?: XOR<CARTELACreateWithoutJOGOInput, CARTELAUncheckedCreateWithoutJOGOInput> | CARTELACreateWithoutJOGOInput[] | CARTELAUncheckedCreateWithoutJOGOInput[]
    connectOrCreate?: CARTELACreateOrConnectWithoutJOGOInput | CARTELACreateOrConnectWithoutJOGOInput[]
    upsert?: CARTELAUpsertWithWhereUniqueWithoutJOGOInput | CARTELAUpsertWithWhereUniqueWithoutJOGOInput[]
    createMany?: CARTELACreateManyJOGOInputEnvelope
    set?: CARTELAWhereUniqueInput | CARTELAWhereUniqueInput[]
    disconnect?: CARTELAWhereUniqueInput | CARTELAWhereUniqueInput[]
    delete?: CARTELAWhereUniqueInput | CARTELAWhereUniqueInput[]
    connect?: CARTELAWhereUniqueInput | CARTELAWhereUniqueInput[]
    update?: CARTELAUpdateWithWhereUniqueWithoutJOGOInput | CARTELAUpdateWithWhereUniqueWithoutJOGOInput[]
    updateMany?: CARTELAUpdateManyWithWhereWithoutJOGOInput | CARTELAUpdateManyWithWhereWithoutJOGOInput[]
    deleteMany?: CARTELAScalarWhereInput | CARTELAScalarWhereInput[]
  }

  export type NUMEROS_SORTEADOSUncheckedUpdateManyWithoutJOGONestedInput = {
    create?: XOR<NUMEROS_SORTEADOSCreateWithoutJOGOInput, NUMEROS_SORTEADOSUncheckedCreateWithoutJOGOInput> | NUMEROS_SORTEADOSCreateWithoutJOGOInput[] | NUMEROS_SORTEADOSUncheckedCreateWithoutJOGOInput[]
    connectOrCreate?: NUMEROS_SORTEADOSCreateOrConnectWithoutJOGOInput | NUMEROS_SORTEADOSCreateOrConnectWithoutJOGOInput[]
    upsert?: NUMEROS_SORTEADOSUpsertWithWhereUniqueWithoutJOGOInput | NUMEROS_SORTEADOSUpsertWithWhereUniqueWithoutJOGOInput[]
    createMany?: NUMEROS_SORTEADOSCreateManyJOGOInputEnvelope
    set?: NUMEROS_SORTEADOSWhereUniqueInput | NUMEROS_SORTEADOSWhereUniqueInput[]
    disconnect?: NUMEROS_SORTEADOSWhereUniqueInput | NUMEROS_SORTEADOSWhereUniqueInput[]
    delete?: NUMEROS_SORTEADOSWhereUniqueInput | NUMEROS_SORTEADOSWhereUniqueInput[]
    connect?: NUMEROS_SORTEADOSWhereUniqueInput | NUMEROS_SORTEADOSWhereUniqueInput[]
    update?: NUMEROS_SORTEADOSUpdateWithWhereUniqueWithoutJOGOInput | NUMEROS_SORTEADOSUpdateWithWhereUniqueWithoutJOGOInput[]
    updateMany?: NUMEROS_SORTEADOSUpdateManyWithWhereWithoutJOGOInput | NUMEROS_SORTEADOSUpdateManyWithWhereWithoutJOGOInput[]
    deleteMany?: NUMEROS_SORTEADOSScalarWhereInput | NUMEROS_SORTEADOSScalarWhereInput[]
  }

  export type PREMIOSUncheckedUpdateManyWithoutJOGONestedInput = {
    create?: XOR<PREMIOSCreateWithoutJOGOInput, PREMIOSUncheckedCreateWithoutJOGOInput> | PREMIOSCreateWithoutJOGOInput[] | PREMIOSUncheckedCreateWithoutJOGOInput[]
    connectOrCreate?: PREMIOSCreateOrConnectWithoutJOGOInput | PREMIOSCreateOrConnectWithoutJOGOInput[]
    upsert?: PREMIOSUpsertWithWhereUniqueWithoutJOGOInput | PREMIOSUpsertWithWhereUniqueWithoutJOGOInput[]
    createMany?: PREMIOSCreateManyJOGOInputEnvelope
    set?: PREMIOSWhereUniqueInput | PREMIOSWhereUniqueInput[]
    disconnect?: PREMIOSWhereUniqueInput | PREMIOSWhereUniqueInput[]
    delete?: PREMIOSWhereUniqueInput | PREMIOSWhereUniqueInput[]
    connect?: PREMIOSWhereUniqueInput | PREMIOSWhereUniqueInput[]
    update?: PREMIOSUpdateWithWhereUniqueWithoutJOGOInput | PREMIOSUpdateWithWhereUniqueWithoutJOGOInput[]
    updateMany?: PREMIOSUpdateManyWithWhereWithoutJOGOInput | PREMIOSUpdateManyWithWhereWithoutJOGOInput[]
    deleteMany?: PREMIOSScalarWhereInput | PREMIOSScalarWhereInput[]
  }

  export type CARTELACreateNestedOneWithoutNUMEROS_CARTELAInput = {
    create?: XOR<CARTELACreateWithoutNUMEROS_CARTELAInput, CARTELAUncheckedCreateWithoutNUMEROS_CARTELAInput>
    connectOrCreate?: CARTELACreateOrConnectWithoutNUMEROS_CARTELAInput
    connect?: CARTELAWhereUniqueInput
  }

  export type CARTELAUpdateOneRequiredWithoutNUMEROS_CARTELANestedInput = {
    create?: XOR<CARTELACreateWithoutNUMEROS_CARTELAInput, CARTELAUncheckedCreateWithoutNUMEROS_CARTELAInput>
    connectOrCreate?: CARTELACreateOrConnectWithoutNUMEROS_CARTELAInput
    upsert?: CARTELAUpsertWithoutNUMEROS_CARTELAInput
    connect?: CARTELAWhereUniqueInput
    update?: XOR<XOR<CARTELAUpdateToOneWithWhereWithoutNUMEROS_CARTELAInput, CARTELAUpdateWithoutNUMEROS_CARTELAInput>, CARTELAUncheckedUpdateWithoutNUMEROS_CARTELAInput>
  }

  export type JOGOCreateNestedOneWithoutNUMEROS_SORTEADOSInput = {
    create?: XOR<JOGOCreateWithoutNUMEROS_SORTEADOSInput, JOGOUncheckedCreateWithoutNUMEROS_SORTEADOSInput>
    connectOrCreate?: JOGOCreateOrConnectWithoutNUMEROS_SORTEADOSInput
    connect?: JOGOWhereUniqueInput
  }

  export type JOGOUpdateOneRequiredWithoutNUMEROS_SORTEADOSNestedInput = {
    create?: XOR<JOGOCreateWithoutNUMEROS_SORTEADOSInput, JOGOUncheckedCreateWithoutNUMEROS_SORTEADOSInput>
    connectOrCreate?: JOGOCreateOrConnectWithoutNUMEROS_SORTEADOSInput
    upsert?: JOGOUpsertWithoutNUMEROS_SORTEADOSInput
    connect?: JOGOWhereUniqueInput
    update?: XOR<XOR<JOGOUpdateToOneWithWhereWithoutNUMEROS_SORTEADOSInput, JOGOUpdateWithoutNUMEROS_SORTEADOSInput>, JOGOUncheckedUpdateWithoutNUMEROS_SORTEADOSInput>
  }

  export type JOGOCreateNestedOneWithoutPREMIOSInput = {
    create?: XOR<JOGOCreateWithoutPREMIOSInput, JOGOUncheckedCreateWithoutPREMIOSInput>
    connectOrCreate?: JOGOCreateOrConnectWithoutPREMIOSInput
    connect?: JOGOWhereUniqueInput
  }

  export type USUARIOCreateNestedOneWithoutPREMIOSInput = {
    create?: XOR<USUARIOCreateWithoutPREMIOSInput, USUARIOUncheckedCreateWithoutPREMIOSInput>
    connectOrCreate?: USUARIOCreateOrConnectWithoutPREMIOSInput
    connect?: USUARIOWhereUniqueInput
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type JOGOUpdateOneRequiredWithoutPREMIOSNestedInput = {
    create?: XOR<JOGOCreateWithoutPREMIOSInput, JOGOUncheckedCreateWithoutPREMIOSInput>
    connectOrCreate?: JOGOCreateOrConnectWithoutPREMIOSInput
    upsert?: JOGOUpsertWithoutPREMIOSInput
    connect?: JOGOWhereUniqueInput
    update?: XOR<XOR<JOGOUpdateToOneWithWhereWithoutPREMIOSInput, JOGOUpdateWithoutPREMIOSInput>, JOGOUncheckedUpdateWithoutPREMIOSInput>
  }

  export type USUARIOUpdateOneWithoutPREMIOSNestedInput = {
    create?: XOR<USUARIOCreateWithoutPREMIOSInput, USUARIOUncheckedCreateWithoutPREMIOSInput>
    connectOrCreate?: USUARIOCreateOrConnectWithoutPREMIOSInput
    upsert?: USUARIOUpsertWithoutPREMIOSInput
    disconnect?: USUARIOWhereInput | boolean
    delete?: USUARIOWhereInput | boolean
    connect?: USUARIOWhereUniqueInput
    update?: XOR<XOR<USUARIOUpdateToOneWithWhereWithoutPREMIOSInput, USUARIOUpdateWithoutPREMIOSInput>, USUARIOUncheckedUpdateWithoutPREMIOSInput>
  }

  export type JOGOCreateNestedManyWithoutSALAInput = {
    create?: XOR<JOGOCreateWithoutSALAInput, JOGOUncheckedCreateWithoutSALAInput> | JOGOCreateWithoutSALAInput[] | JOGOUncheckedCreateWithoutSALAInput[]
    connectOrCreate?: JOGOCreateOrConnectWithoutSALAInput | JOGOCreateOrConnectWithoutSALAInput[]
    createMany?: JOGOCreateManySALAInputEnvelope
    connect?: JOGOWhereUniqueInput | JOGOWhereUniqueInput[]
  }

  export type JOGOUncheckedCreateNestedManyWithoutSALAInput = {
    create?: XOR<JOGOCreateWithoutSALAInput, JOGOUncheckedCreateWithoutSALAInput> | JOGOCreateWithoutSALAInput[] | JOGOUncheckedCreateWithoutSALAInput[]
    connectOrCreate?: JOGOCreateOrConnectWithoutSALAInput | JOGOCreateOrConnectWithoutSALAInput[]
    createMany?: JOGOCreateManySALAInputEnvelope
    connect?: JOGOWhereUniqueInput | JOGOWhereUniqueInput[]
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type JOGOUpdateManyWithoutSALANestedInput = {
    create?: XOR<JOGOCreateWithoutSALAInput, JOGOUncheckedCreateWithoutSALAInput> | JOGOCreateWithoutSALAInput[] | JOGOUncheckedCreateWithoutSALAInput[]
    connectOrCreate?: JOGOCreateOrConnectWithoutSALAInput | JOGOCreateOrConnectWithoutSALAInput[]
    upsert?: JOGOUpsertWithWhereUniqueWithoutSALAInput | JOGOUpsertWithWhereUniqueWithoutSALAInput[]
    createMany?: JOGOCreateManySALAInputEnvelope
    set?: JOGOWhereUniqueInput | JOGOWhereUniqueInput[]
    disconnect?: JOGOWhereUniqueInput | JOGOWhereUniqueInput[]
    delete?: JOGOWhereUniqueInput | JOGOWhereUniqueInput[]
    connect?: JOGOWhereUniqueInput | JOGOWhereUniqueInput[]
    update?: JOGOUpdateWithWhereUniqueWithoutSALAInput | JOGOUpdateWithWhereUniqueWithoutSALAInput[]
    updateMany?: JOGOUpdateManyWithWhereWithoutSALAInput | JOGOUpdateManyWithWhereWithoutSALAInput[]
    deleteMany?: JOGOScalarWhereInput | JOGOScalarWhereInput[]
  }

  export type JOGOUncheckedUpdateManyWithoutSALANestedInput = {
    create?: XOR<JOGOCreateWithoutSALAInput, JOGOUncheckedCreateWithoutSALAInput> | JOGOCreateWithoutSALAInput[] | JOGOUncheckedCreateWithoutSALAInput[]
    connectOrCreate?: JOGOCreateOrConnectWithoutSALAInput | JOGOCreateOrConnectWithoutSALAInput[]
    upsert?: JOGOUpsertWithWhereUniqueWithoutSALAInput | JOGOUpsertWithWhereUniqueWithoutSALAInput[]
    createMany?: JOGOCreateManySALAInputEnvelope
    set?: JOGOWhereUniqueInput | JOGOWhereUniqueInput[]
    disconnect?: JOGOWhereUniqueInput | JOGOWhereUniqueInput[]
    delete?: JOGOWhereUniqueInput | JOGOWhereUniqueInput[]
    connect?: JOGOWhereUniqueInput | JOGOWhereUniqueInput[]
    update?: JOGOUpdateWithWhereUniqueWithoutSALAInput | JOGOUpdateWithWhereUniqueWithoutSALAInput[]
    updateMany?: JOGOUpdateManyWithWhereWithoutSALAInput | JOGOUpdateManyWithWhereWithoutSALAInput[]
    deleteMany?: JOGOScalarWhereInput | JOGOScalarWhereInput[]
  }

  export type CARTELACreateNestedManyWithoutUSUARIOInput = {
    create?: XOR<CARTELACreateWithoutUSUARIOInput, CARTELAUncheckedCreateWithoutUSUARIOInput> | CARTELACreateWithoutUSUARIOInput[] | CARTELAUncheckedCreateWithoutUSUARIOInput[]
    connectOrCreate?: CARTELACreateOrConnectWithoutUSUARIOInput | CARTELACreateOrConnectWithoutUSUARIOInput[]
    createMany?: CARTELACreateManyUSUARIOInputEnvelope
    connect?: CARTELAWhereUniqueInput | CARTELAWhereUniqueInput[]
  }

  export type JOGOCreateNestedManyWithoutUSUARIOInput = {
    create?: XOR<JOGOCreateWithoutUSUARIOInput, JOGOUncheckedCreateWithoutUSUARIOInput> | JOGOCreateWithoutUSUARIOInput[] | JOGOUncheckedCreateWithoutUSUARIOInput[]
    connectOrCreate?: JOGOCreateOrConnectWithoutUSUARIOInput | JOGOCreateOrConnectWithoutUSUARIOInput[]
    createMany?: JOGOCreateManyUSUARIOInputEnvelope
    connect?: JOGOWhereUniqueInput | JOGOWhereUniqueInput[]
  }

  export type PREMIOSCreateNestedManyWithoutUSUARIOInput = {
    create?: XOR<PREMIOSCreateWithoutUSUARIOInput, PREMIOSUncheckedCreateWithoutUSUARIOInput> | PREMIOSCreateWithoutUSUARIOInput[] | PREMIOSUncheckedCreateWithoutUSUARIOInput[]
    connectOrCreate?: PREMIOSCreateOrConnectWithoutUSUARIOInput | PREMIOSCreateOrConnectWithoutUSUARIOInput[]
    createMany?: PREMIOSCreateManyUSUARIOInputEnvelope
    connect?: PREMIOSWhereUniqueInput | PREMIOSWhereUniqueInput[]
  }

  export type CARTELAUncheckedCreateNestedManyWithoutUSUARIOInput = {
    create?: XOR<CARTELACreateWithoutUSUARIOInput, CARTELAUncheckedCreateWithoutUSUARIOInput> | CARTELACreateWithoutUSUARIOInput[] | CARTELAUncheckedCreateWithoutUSUARIOInput[]
    connectOrCreate?: CARTELACreateOrConnectWithoutUSUARIOInput | CARTELACreateOrConnectWithoutUSUARIOInput[]
    createMany?: CARTELACreateManyUSUARIOInputEnvelope
    connect?: CARTELAWhereUniqueInput | CARTELAWhereUniqueInput[]
  }

  export type JOGOUncheckedCreateNestedManyWithoutUSUARIOInput = {
    create?: XOR<JOGOCreateWithoutUSUARIOInput, JOGOUncheckedCreateWithoutUSUARIOInput> | JOGOCreateWithoutUSUARIOInput[] | JOGOUncheckedCreateWithoutUSUARIOInput[]
    connectOrCreate?: JOGOCreateOrConnectWithoutUSUARIOInput | JOGOCreateOrConnectWithoutUSUARIOInput[]
    createMany?: JOGOCreateManyUSUARIOInputEnvelope
    connect?: JOGOWhereUniqueInput | JOGOWhereUniqueInput[]
  }

  export type PREMIOSUncheckedCreateNestedManyWithoutUSUARIOInput = {
    create?: XOR<PREMIOSCreateWithoutUSUARIOInput, PREMIOSUncheckedCreateWithoutUSUARIOInput> | PREMIOSCreateWithoutUSUARIOInput[] | PREMIOSUncheckedCreateWithoutUSUARIOInput[]
    connectOrCreate?: PREMIOSCreateOrConnectWithoutUSUARIOInput | PREMIOSCreateOrConnectWithoutUSUARIOInput[]
    createMany?: PREMIOSCreateManyUSUARIOInputEnvelope
    connect?: PREMIOSWhereUniqueInput | PREMIOSWhereUniqueInput[]
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type CARTELAUpdateManyWithoutUSUARIONestedInput = {
    create?: XOR<CARTELACreateWithoutUSUARIOInput, CARTELAUncheckedCreateWithoutUSUARIOInput> | CARTELACreateWithoutUSUARIOInput[] | CARTELAUncheckedCreateWithoutUSUARIOInput[]
    connectOrCreate?: CARTELACreateOrConnectWithoutUSUARIOInput | CARTELACreateOrConnectWithoutUSUARIOInput[]
    upsert?: CARTELAUpsertWithWhereUniqueWithoutUSUARIOInput | CARTELAUpsertWithWhereUniqueWithoutUSUARIOInput[]
    createMany?: CARTELACreateManyUSUARIOInputEnvelope
    set?: CARTELAWhereUniqueInput | CARTELAWhereUniqueInput[]
    disconnect?: CARTELAWhereUniqueInput | CARTELAWhereUniqueInput[]
    delete?: CARTELAWhereUniqueInput | CARTELAWhereUniqueInput[]
    connect?: CARTELAWhereUniqueInput | CARTELAWhereUniqueInput[]
    update?: CARTELAUpdateWithWhereUniqueWithoutUSUARIOInput | CARTELAUpdateWithWhereUniqueWithoutUSUARIOInput[]
    updateMany?: CARTELAUpdateManyWithWhereWithoutUSUARIOInput | CARTELAUpdateManyWithWhereWithoutUSUARIOInput[]
    deleteMany?: CARTELAScalarWhereInput | CARTELAScalarWhereInput[]
  }

  export type JOGOUpdateManyWithoutUSUARIONestedInput = {
    create?: XOR<JOGOCreateWithoutUSUARIOInput, JOGOUncheckedCreateWithoutUSUARIOInput> | JOGOCreateWithoutUSUARIOInput[] | JOGOUncheckedCreateWithoutUSUARIOInput[]
    connectOrCreate?: JOGOCreateOrConnectWithoutUSUARIOInput | JOGOCreateOrConnectWithoutUSUARIOInput[]
    upsert?: JOGOUpsertWithWhereUniqueWithoutUSUARIOInput | JOGOUpsertWithWhereUniqueWithoutUSUARIOInput[]
    createMany?: JOGOCreateManyUSUARIOInputEnvelope
    set?: JOGOWhereUniqueInput | JOGOWhereUniqueInput[]
    disconnect?: JOGOWhereUniqueInput | JOGOWhereUniqueInput[]
    delete?: JOGOWhereUniqueInput | JOGOWhereUniqueInput[]
    connect?: JOGOWhereUniqueInput | JOGOWhereUniqueInput[]
    update?: JOGOUpdateWithWhereUniqueWithoutUSUARIOInput | JOGOUpdateWithWhereUniqueWithoutUSUARIOInput[]
    updateMany?: JOGOUpdateManyWithWhereWithoutUSUARIOInput | JOGOUpdateManyWithWhereWithoutUSUARIOInput[]
    deleteMany?: JOGOScalarWhereInput | JOGOScalarWhereInput[]
  }

  export type PREMIOSUpdateManyWithoutUSUARIONestedInput = {
    create?: XOR<PREMIOSCreateWithoutUSUARIOInput, PREMIOSUncheckedCreateWithoutUSUARIOInput> | PREMIOSCreateWithoutUSUARIOInput[] | PREMIOSUncheckedCreateWithoutUSUARIOInput[]
    connectOrCreate?: PREMIOSCreateOrConnectWithoutUSUARIOInput | PREMIOSCreateOrConnectWithoutUSUARIOInput[]
    upsert?: PREMIOSUpsertWithWhereUniqueWithoutUSUARIOInput | PREMIOSUpsertWithWhereUniqueWithoutUSUARIOInput[]
    createMany?: PREMIOSCreateManyUSUARIOInputEnvelope
    set?: PREMIOSWhereUniqueInput | PREMIOSWhereUniqueInput[]
    disconnect?: PREMIOSWhereUniqueInput | PREMIOSWhereUniqueInput[]
    delete?: PREMIOSWhereUniqueInput | PREMIOSWhereUniqueInput[]
    connect?: PREMIOSWhereUniqueInput | PREMIOSWhereUniqueInput[]
    update?: PREMIOSUpdateWithWhereUniqueWithoutUSUARIOInput | PREMIOSUpdateWithWhereUniqueWithoutUSUARIOInput[]
    updateMany?: PREMIOSUpdateManyWithWhereWithoutUSUARIOInput | PREMIOSUpdateManyWithWhereWithoutUSUARIOInput[]
    deleteMany?: PREMIOSScalarWhereInput | PREMIOSScalarWhereInput[]
  }

  export type CARTELAUncheckedUpdateManyWithoutUSUARIONestedInput = {
    create?: XOR<CARTELACreateWithoutUSUARIOInput, CARTELAUncheckedCreateWithoutUSUARIOInput> | CARTELACreateWithoutUSUARIOInput[] | CARTELAUncheckedCreateWithoutUSUARIOInput[]
    connectOrCreate?: CARTELACreateOrConnectWithoutUSUARIOInput | CARTELACreateOrConnectWithoutUSUARIOInput[]
    upsert?: CARTELAUpsertWithWhereUniqueWithoutUSUARIOInput | CARTELAUpsertWithWhereUniqueWithoutUSUARIOInput[]
    createMany?: CARTELACreateManyUSUARIOInputEnvelope
    set?: CARTELAWhereUniqueInput | CARTELAWhereUniqueInput[]
    disconnect?: CARTELAWhereUniqueInput | CARTELAWhereUniqueInput[]
    delete?: CARTELAWhereUniqueInput | CARTELAWhereUniqueInput[]
    connect?: CARTELAWhereUniqueInput | CARTELAWhereUniqueInput[]
    update?: CARTELAUpdateWithWhereUniqueWithoutUSUARIOInput | CARTELAUpdateWithWhereUniqueWithoutUSUARIOInput[]
    updateMany?: CARTELAUpdateManyWithWhereWithoutUSUARIOInput | CARTELAUpdateManyWithWhereWithoutUSUARIOInput[]
    deleteMany?: CARTELAScalarWhereInput | CARTELAScalarWhereInput[]
  }

  export type JOGOUncheckedUpdateManyWithoutUSUARIONestedInput = {
    create?: XOR<JOGOCreateWithoutUSUARIOInput, JOGOUncheckedCreateWithoutUSUARIOInput> | JOGOCreateWithoutUSUARIOInput[] | JOGOUncheckedCreateWithoutUSUARIOInput[]
    connectOrCreate?: JOGOCreateOrConnectWithoutUSUARIOInput | JOGOCreateOrConnectWithoutUSUARIOInput[]
    upsert?: JOGOUpsertWithWhereUniqueWithoutUSUARIOInput | JOGOUpsertWithWhereUniqueWithoutUSUARIOInput[]
    createMany?: JOGOCreateManyUSUARIOInputEnvelope
    set?: JOGOWhereUniqueInput | JOGOWhereUniqueInput[]
    disconnect?: JOGOWhereUniqueInput | JOGOWhereUniqueInput[]
    delete?: JOGOWhereUniqueInput | JOGOWhereUniqueInput[]
    connect?: JOGOWhereUniqueInput | JOGOWhereUniqueInput[]
    update?: JOGOUpdateWithWhereUniqueWithoutUSUARIOInput | JOGOUpdateWithWhereUniqueWithoutUSUARIOInput[]
    updateMany?: JOGOUpdateManyWithWhereWithoutUSUARIOInput | JOGOUpdateManyWithWhereWithoutUSUARIOInput[]
    deleteMany?: JOGOScalarWhereInput | JOGOScalarWhereInput[]
  }

  export type PREMIOSUncheckedUpdateManyWithoutUSUARIONestedInput = {
    create?: XOR<PREMIOSCreateWithoutUSUARIOInput, PREMIOSUncheckedCreateWithoutUSUARIOInput> | PREMIOSCreateWithoutUSUARIOInput[] | PREMIOSUncheckedCreateWithoutUSUARIOInput[]
    connectOrCreate?: PREMIOSCreateOrConnectWithoutUSUARIOInput | PREMIOSCreateOrConnectWithoutUSUARIOInput[]
    upsert?: PREMIOSUpsertWithWhereUniqueWithoutUSUARIOInput | PREMIOSUpsertWithWhereUniqueWithoutUSUARIOInput[]
    createMany?: PREMIOSCreateManyUSUARIOInputEnvelope
    set?: PREMIOSWhereUniqueInput | PREMIOSWhereUniqueInput[]
    disconnect?: PREMIOSWhereUniqueInput | PREMIOSWhereUniqueInput[]
    delete?: PREMIOSWhereUniqueInput | PREMIOSWhereUniqueInput[]
    connect?: PREMIOSWhereUniqueInput | PREMIOSWhereUniqueInput[]
    update?: PREMIOSUpdateWithWhereUniqueWithoutUSUARIOInput | PREMIOSUpdateWithWhereUniqueWithoutUSUARIOInput[]
    updateMany?: PREMIOSUpdateManyWithWhereWithoutUSUARIOInput | PREMIOSUpdateManyWithWhereWithoutUSUARIOInput[]
    deleteMany?: PREMIOSScalarWhereInput | PREMIOSScalarWhereInput[]
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type JOGOCreateWithoutCARTELAInput = {
    data_hora: Date | string
    preco_cartela: Decimal | DecimalJsLike | number | string
    SALA: SALACreateNestedOneWithoutJOGOInput
    USUARIO?: USUARIOCreateNestedOneWithoutJOGOInput
    NUMEROS_SORTEADOS?: NUMEROS_SORTEADOSCreateNestedManyWithoutJOGOInput
    PREMIOS?: PREMIOSCreateNestedManyWithoutJOGOInput
  }

  export type JOGOUncheckedCreateWithoutCARTELAInput = {
    id_jogo?: number
    data_hora: Date | string
    id_sala: number
    id_usuario_vencedor?: number | null
    preco_cartela: Decimal | DecimalJsLike | number | string
    NUMEROS_SORTEADOS?: NUMEROS_SORTEADOSUncheckedCreateNestedManyWithoutJOGOInput
    PREMIOS?: PREMIOSUncheckedCreateNestedManyWithoutJOGOInput
  }

  export type JOGOCreateOrConnectWithoutCARTELAInput = {
    where: JOGOWhereUniqueInput
    create: XOR<JOGOCreateWithoutCARTELAInput, JOGOUncheckedCreateWithoutCARTELAInput>
  }

  export type USUARIOCreateWithoutCARTELAInput = {
    nome: string
    email: string
    senha: string
    creditos: Decimal | DecimalJsLike | number | string
    is_admin?: boolean
    JOGO?: JOGOCreateNestedManyWithoutUSUARIOInput
    PREMIOS?: PREMIOSCreateNestedManyWithoutUSUARIOInput
  }

  export type USUARIOUncheckedCreateWithoutCARTELAInput = {
    id_usuario?: number
    nome: string
    email: string
    senha: string
    creditos: Decimal | DecimalJsLike | number | string
    is_admin?: boolean
    JOGO?: JOGOUncheckedCreateNestedManyWithoutUSUARIOInput
    PREMIOS?: PREMIOSUncheckedCreateNestedManyWithoutUSUARIOInput
  }

  export type USUARIOCreateOrConnectWithoutCARTELAInput = {
    where: USUARIOWhereUniqueInput
    create: XOR<USUARIOCreateWithoutCARTELAInput, USUARIOUncheckedCreateWithoutCARTELAInput>
  }

  export type NUMEROS_CARTELACreateWithoutCARTELAInput = {
    numero: number
  }

  export type NUMEROS_CARTELAUncheckedCreateWithoutCARTELAInput = {
    id_numero_cartela?: number
    numero: number
  }

  export type NUMEROS_CARTELACreateOrConnectWithoutCARTELAInput = {
    where: NUMEROS_CARTELAWhereUniqueInput
    create: XOR<NUMEROS_CARTELACreateWithoutCARTELAInput, NUMEROS_CARTELAUncheckedCreateWithoutCARTELAInput>
  }

  export type NUMEROS_CARTELACreateManyCARTELAInputEnvelope = {
    data: NUMEROS_CARTELACreateManyCARTELAInput | NUMEROS_CARTELACreateManyCARTELAInput[]
    skipDuplicates?: boolean
  }

  export type JOGOUpsertWithoutCARTELAInput = {
    update: XOR<JOGOUpdateWithoutCARTELAInput, JOGOUncheckedUpdateWithoutCARTELAInput>
    create: XOR<JOGOCreateWithoutCARTELAInput, JOGOUncheckedCreateWithoutCARTELAInput>
    where?: JOGOWhereInput
  }

  export type JOGOUpdateToOneWithWhereWithoutCARTELAInput = {
    where?: JOGOWhereInput
    data: XOR<JOGOUpdateWithoutCARTELAInput, JOGOUncheckedUpdateWithoutCARTELAInput>
  }

  export type JOGOUpdateWithoutCARTELAInput = {
    data_hora?: DateTimeFieldUpdateOperationsInput | Date | string
    preco_cartela?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    SALA?: SALAUpdateOneRequiredWithoutJOGONestedInput
    USUARIO?: USUARIOUpdateOneWithoutJOGONestedInput
    NUMEROS_SORTEADOS?: NUMEROS_SORTEADOSUpdateManyWithoutJOGONestedInput
    PREMIOS?: PREMIOSUpdateManyWithoutJOGONestedInput
  }

  export type JOGOUncheckedUpdateWithoutCARTELAInput = {
    id_jogo?: IntFieldUpdateOperationsInput | number
    data_hora?: DateTimeFieldUpdateOperationsInput | Date | string
    id_sala?: IntFieldUpdateOperationsInput | number
    id_usuario_vencedor?: NullableIntFieldUpdateOperationsInput | number | null
    preco_cartela?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    NUMEROS_SORTEADOS?: NUMEROS_SORTEADOSUncheckedUpdateManyWithoutJOGONestedInput
    PREMIOS?: PREMIOSUncheckedUpdateManyWithoutJOGONestedInput
  }

  export type USUARIOUpsertWithoutCARTELAInput = {
    update: XOR<USUARIOUpdateWithoutCARTELAInput, USUARIOUncheckedUpdateWithoutCARTELAInput>
    create: XOR<USUARIOCreateWithoutCARTELAInput, USUARIOUncheckedCreateWithoutCARTELAInput>
    where?: USUARIOWhereInput
  }

  export type USUARIOUpdateToOneWithWhereWithoutCARTELAInput = {
    where?: USUARIOWhereInput
    data: XOR<USUARIOUpdateWithoutCARTELAInput, USUARIOUncheckedUpdateWithoutCARTELAInput>
  }

  export type USUARIOUpdateWithoutCARTELAInput = {
    nome?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    creditos?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    is_admin?: BoolFieldUpdateOperationsInput | boolean
    JOGO?: JOGOUpdateManyWithoutUSUARIONestedInput
    PREMIOS?: PREMIOSUpdateManyWithoutUSUARIONestedInput
  }

  export type USUARIOUncheckedUpdateWithoutCARTELAInput = {
    id_usuario?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    creditos?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    is_admin?: BoolFieldUpdateOperationsInput | boolean
    JOGO?: JOGOUncheckedUpdateManyWithoutUSUARIONestedInput
    PREMIOS?: PREMIOSUncheckedUpdateManyWithoutUSUARIONestedInput
  }

  export type NUMEROS_CARTELAUpsertWithWhereUniqueWithoutCARTELAInput = {
    where: NUMEROS_CARTELAWhereUniqueInput
    update: XOR<NUMEROS_CARTELAUpdateWithoutCARTELAInput, NUMEROS_CARTELAUncheckedUpdateWithoutCARTELAInput>
    create: XOR<NUMEROS_CARTELACreateWithoutCARTELAInput, NUMEROS_CARTELAUncheckedCreateWithoutCARTELAInput>
  }

  export type NUMEROS_CARTELAUpdateWithWhereUniqueWithoutCARTELAInput = {
    where: NUMEROS_CARTELAWhereUniqueInput
    data: XOR<NUMEROS_CARTELAUpdateWithoutCARTELAInput, NUMEROS_CARTELAUncheckedUpdateWithoutCARTELAInput>
  }

  export type NUMEROS_CARTELAUpdateManyWithWhereWithoutCARTELAInput = {
    where: NUMEROS_CARTELAScalarWhereInput
    data: XOR<NUMEROS_CARTELAUpdateManyMutationInput, NUMEROS_CARTELAUncheckedUpdateManyWithoutCARTELAInput>
  }

  export type NUMEROS_CARTELAScalarWhereInput = {
    AND?: NUMEROS_CARTELAScalarWhereInput | NUMEROS_CARTELAScalarWhereInput[]
    OR?: NUMEROS_CARTELAScalarWhereInput[]
    NOT?: NUMEROS_CARTELAScalarWhereInput | NUMEROS_CARTELAScalarWhereInput[]
    id_numero_cartela?: IntFilter<"NUMEROS_CARTELA"> | number
    numero?: IntFilter<"NUMEROS_CARTELA"> | number
    id_cartela?: IntFilter<"NUMEROS_CARTELA"> | number
  }

  export type CARTELACreateWithoutJOGOInput = {
    USUARIO: USUARIOCreateNestedOneWithoutCARTELAInput
    NUMEROS_CARTELA?: NUMEROS_CARTELACreateNestedManyWithoutCARTELAInput
  }

  export type CARTELAUncheckedCreateWithoutJOGOInput = {
    id_cartela?: number
    id_usuario: number
    NUMEROS_CARTELA?: NUMEROS_CARTELAUncheckedCreateNestedManyWithoutCARTELAInput
  }

  export type CARTELACreateOrConnectWithoutJOGOInput = {
    where: CARTELAWhereUniqueInput
    create: XOR<CARTELACreateWithoutJOGOInput, CARTELAUncheckedCreateWithoutJOGOInput>
  }

  export type CARTELACreateManyJOGOInputEnvelope = {
    data: CARTELACreateManyJOGOInput | CARTELACreateManyJOGOInput[]
    skipDuplicates?: boolean
  }

  export type SALACreateWithoutJOGOInput = {
    nome: string
    descricao?: string | null
  }

  export type SALAUncheckedCreateWithoutJOGOInput = {
    id_sala?: number
    nome: string
    descricao?: string | null
  }

  export type SALACreateOrConnectWithoutJOGOInput = {
    where: SALAWhereUniqueInput
    create: XOR<SALACreateWithoutJOGOInput, SALAUncheckedCreateWithoutJOGOInput>
  }

  export type USUARIOCreateWithoutJOGOInput = {
    nome: string
    email: string
    senha: string
    creditos: Decimal | DecimalJsLike | number | string
    is_admin?: boolean
    CARTELA?: CARTELACreateNestedManyWithoutUSUARIOInput
    PREMIOS?: PREMIOSCreateNestedManyWithoutUSUARIOInput
  }

  export type USUARIOUncheckedCreateWithoutJOGOInput = {
    id_usuario?: number
    nome: string
    email: string
    senha: string
    creditos: Decimal | DecimalJsLike | number | string
    is_admin?: boolean
    CARTELA?: CARTELAUncheckedCreateNestedManyWithoutUSUARIOInput
    PREMIOS?: PREMIOSUncheckedCreateNestedManyWithoutUSUARIOInput
  }

  export type USUARIOCreateOrConnectWithoutJOGOInput = {
    where: USUARIOWhereUniqueInput
    create: XOR<USUARIOCreateWithoutJOGOInput, USUARIOUncheckedCreateWithoutJOGOInput>
  }

  export type NUMEROS_SORTEADOSCreateWithoutJOGOInput = {
    numero: number
    ordem_sorteio: number
  }

  export type NUMEROS_SORTEADOSUncheckedCreateWithoutJOGOInput = {
    id_numero_sorteado?: number
    numero: number
    ordem_sorteio: number
  }

  export type NUMEROS_SORTEADOSCreateOrConnectWithoutJOGOInput = {
    where: NUMEROS_SORTEADOSWhereUniqueInput
    create: XOR<NUMEROS_SORTEADOSCreateWithoutJOGOInput, NUMEROS_SORTEADOSUncheckedCreateWithoutJOGOInput>
  }

  export type NUMEROS_SORTEADOSCreateManyJOGOInputEnvelope = {
    data: NUMEROS_SORTEADOSCreateManyJOGOInput | NUMEROS_SORTEADOSCreateManyJOGOInput[]
    skipDuplicates?: boolean
  }

  export type PREMIOSCreateWithoutJOGOInput = {
    descricao: string
    valor: Decimal | DecimalJsLike | number | string
    USUARIO?: USUARIOCreateNestedOneWithoutPREMIOSInput
  }

  export type PREMIOSUncheckedCreateWithoutJOGOInput = {
    id_premio?: number
    descricao: string
    valor: Decimal | DecimalJsLike | number | string
    id_usuario?: number | null
  }

  export type PREMIOSCreateOrConnectWithoutJOGOInput = {
    where: PREMIOSWhereUniqueInput
    create: XOR<PREMIOSCreateWithoutJOGOInput, PREMIOSUncheckedCreateWithoutJOGOInput>
  }

  export type PREMIOSCreateManyJOGOInputEnvelope = {
    data: PREMIOSCreateManyJOGOInput | PREMIOSCreateManyJOGOInput[]
    skipDuplicates?: boolean
  }

  export type CARTELAUpsertWithWhereUniqueWithoutJOGOInput = {
    where: CARTELAWhereUniqueInput
    update: XOR<CARTELAUpdateWithoutJOGOInput, CARTELAUncheckedUpdateWithoutJOGOInput>
    create: XOR<CARTELACreateWithoutJOGOInput, CARTELAUncheckedCreateWithoutJOGOInput>
  }

  export type CARTELAUpdateWithWhereUniqueWithoutJOGOInput = {
    where: CARTELAWhereUniqueInput
    data: XOR<CARTELAUpdateWithoutJOGOInput, CARTELAUncheckedUpdateWithoutJOGOInput>
  }

  export type CARTELAUpdateManyWithWhereWithoutJOGOInput = {
    where: CARTELAScalarWhereInput
    data: XOR<CARTELAUpdateManyMutationInput, CARTELAUncheckedUpdateManyWithoutJOGOInput>
  }

  export type CARTELAScalarWhereInput = {
    AND?: CARTELAScalarWhereInput | CARTELAScalarWhereInput[]
    OR?: CARTELAScalarWhereInput[]
    NOT?: CARTELAScalarWhereInput | CARTELAScalarWhereInput[]
    id_cartela?: IntFilter<"CARTELA"> | number
    id_usuario?: IntFilter<"CARTELA"> | number
    id_jogo?: IntFilter<"CARTELA"> | number
  }

  export type SALAUpsertWithoutJOGOInput = {
    update: XOR<SALAUpdateWithoutJOGOInput, SALAUncheckedUpdateWithoutJOGOInput>
    create: XOR<SALACreateWithoutJOGOInput, SALAUncheckedCreateWithoutJOGOInput>
    where?: SALAWhereInput
  }

  export type SALAUpdateToOneWithWhereWithoutJOGOInput = {
    where?: SALAWhereInput
    data: XOR<SALAUpdateWithoutJOGOInput, SALAUncheckedUpdateWithoutJOGOInput>
  }

  export type SALAUpdateWithoutJOGOInput = {
    nome?: StringFieldUpdateOperationsInput | string
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SALAUncheckedUpdateWithoutJOGOInput = {
    id_sala?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type USUARIOUpsertWithoutJOGOInput = {
    update: XOR<USUARIOUpdateWithoutJOGOInput, USUARIOUncheckedUpdateWithoutJOGOInput>
    create: XOR<USUARIOCreateWithoutJOGOInput, USUARIOUncheckedCreateWithoutJOGOInput>
    where?: USUARIOWhereInput
  }

  export type USUARIOUpdateToOneWithWhereWithoutJOGOInput = {
    where?: USUARIOWhereInput
    data: XOR<USUARIOUpdateWithoutJOGOInput, USUARIOUncheckedUpdateWithoutJOGOInput>
  }

  export type USUARIOUpdateWithoutJOGOInput = {
    nome?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    creditos?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    is_admin?: BoolFieldUpdateOperationsInput | boolean
    CARTELA?: CARTELAUpdateManyWithoutUSUARIONestedInput
    PREMIOS?: PREMIOSUpdateManyWithoutUSUARIONestedInput
  }

  export type USUARIOUncheckedUpdateWithoutJOGOInput = {
    id_usuario?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    creditos?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    is_admin?: BoolFieldUpdateOperationsInput | boolean
    CARTELA?: CARTELAUncheckedUpdateManyWithoutUSUARIONestedInput
    PREMIOS?: PREMIOSUncheckedUpdateManyWithoutUSUARIONestedInput
  }

  export type NUMEROS_SORTEADOSUpsertWithWhereUniqueWithoutJOGOInput = {
    where: NUMEROS_SORTEADOSWhereUniqueInput
    update: XOR<NUMEROS_SORTEADOSUpdateWithoutJOGOInput, NUMEROS_SORTEADOSUncheckedUpdateWithoutJOGOInput>
    create: XOR<NUMEROS_SORTEADOSCreateWithoutJOGOInput, NUMEROS_SORTEADOSUncheckedCreateWithoutJOGOInput>
  }

  export type NUMEROS_SORTEADOSUpdateWithWhereUniqueWithoutJOGOInput = {
    where: NUMEROS_SORTEADOSWhereUniqueInput
    data: XOR<NUMEROS_SORTEADOSUpdateWithoutJOGOInput, NUMEROS_SORTEADOSUncheckedUpdateWithoutJOGOInput>
  }

  export type NUMEROS_SORTEADOSUpdateManyWithWhereWithoutJOGOInput = {
    where: NUMEROS_SORTEADOSScalarWhereInput
    data: XOR<NUMEROS_SORTEADOSUpdateManyMutationInput, NUMEROS_SORTEADOSUncheckedUpdateManyWithoutJOGOInput>
  }

  export type NUMEROS_SORTEADOSScalarWhereInput = {
    AND?: NUMEROS_SORTEADOSScalarWhereInput | NUMEROS_SORTEADOSScalarWhereInput[]
    OR?: NUMEROS_SORTEADOSScalarWhereInput[]
    NOT?: NUMEROS_SORTEADOSScalarWhereInput | NUMEROS_SORTEADOSScalarWhereInput[]
    id_numero_sorteado?: IntFilter<"NUMEROS_SORTEADOS"> | number
    numero?: IntFilter<"NUMEROS_SORTEADOS"> | number
    ordem_sorteio?: IntFilter<"NUMEROS_SORTEADOS"> | number
    id_jogo?: IntFilter<"NUMEROS_SORTEADOS"> | number
  }

  export type PREMIOSUpsertWithWhereUniqueWithoutJOGOInput = {
    where: PREMIOSWhereUniqueInput
    update: XOR<PREMIOSUpdateWithoutJOGOInput, PREMIOSUncheckedUpdateWithoutJOGOInput>
    create: XOR<PREMIOSCreateWithoutJOGOInput, PREMIOSUncheckedCreateWithoutJOGOInput>
  }

  export type PREMIOSUpdateWithWhereUniqueWithoutJOGOInput = {
    where: PREMIOSWhereUniqueInput
    data: XOR<PREMIOSUpdateWithoutJOGOInput, PREMIOSUncheckedUpdateWithoutJOGOInput>
  }

  export type PREMIOSUpdateManyWithWhereWithoutJOGOInput = {
    where: PREMIOSScalarWhereInput
    data: XOR<PREMIOSUpdateManyMutationInput, PREMIOSUncheckedUpdateManyWithoutJOGOInput>
  }

  export type PREMIOSScalarWhereInput = {
    AND?: PREMIOSScalarWhereInput | PREMIOSScalarWhereInput[]
    OR?: PREMIOSScalarWhereInput[]
    NOT?: PREMIOSScalarWhereInput | PREMIOSScalarWhereInput[]
    id_premio?: IntFilter<"PREMIOS"> | number
    descricao?: StringFilter<"PREMIOS"> | string
    valor?: DecimalFilter<"PREMIOS"> | Decimal | DecimalJsLike | number | string
    id_usuario?: IntNullableFilter<"PREMIOS"> | number | null
    id_jogo?: IntFilter<"PREMIOS"> | number
  }

  export type CARTELACreateWithoutNUMEROS_CARTELAInput = {
    JOGO: JOGOCreateNestedOneWithoutCARTELAInput
    USUARIO: USUARIOCreateNestedOneWithoutCARTELAInput
  }

  export type CARTELAUncheckedCreateWithoutNUMEROS_CARTELAInput = {
    id_cartela?: number
    id_usuario: number
    id_jogo: number
  }

  export type CARTELACreateOrConnectWithoutNUMEROS_CARTELAInput = {
    where: CARTELAWhereUniqueInput
    create: XOR<CARTELACreateWithoutNUMEROS_CARTELAInput, CARTELAUncheckedCreateWithoutNUMEROS_CARTELAInput>
  }

  export type CARTELAUpsertWithoutNUMEROS_CARTELAInput = {
    update: XOR<CARTELAUpdateWithoutNUMEROS_CARTELAInput, CARTELAUncheckedUpdateWithoutNUMEROS_CARTELAInput>
    create: XOR<CARTELACreateWithoutNUMEROS_CARTELAInput, CARTELAUncheckedCreateWithoutNUMEROS_CARTELAInput>
    where?: CARTELAWhereInput
  }

  export type CARTELAUpdateToOneWithWhereWithoutNUMEROS_CARTELAInput = {
    where?: CARTELAWhereInput
    data: XOR<CARTELAUpdateWithoutNUMEROS_CARTELAInput, CARTELAUncheckedUpdateWithoutNUMEROS_CARTELAInput>
  }

  export type CARTELAUpdateWithoutNUMEROS_CARTELAInput = {
    JOGO?: JOGOUpdateOneRequiredWithoutCARTELANestedInput
    USUARIO?: USUARIOUpdateOneRequiredWithoutCARTELANestedInput
  }

  export type CARTELAUncheckedUpdateWithoutNUMEROS_CARTELAInput = {
    id_cartela?: IntFieldUpdateOperationsInput | number
    id_usuario?: IntFieldUpdateOperationsInput | number
    id_jogo?: IntFieldUpdateOperationsInput | number
  }

  export type JOGOCreateWithoutNUMEROS_SORTEADOSInput = {
    data_hora: Date | string
    preco_cartela: Decimal | DecimalJsLike | number | string
    CARTELA?: CARTELACreateNestedManyWithoutJOGOInput
    SALA: SALACreateNestedOneWithoutJOGOInput
    USUARIO?: USUARIOCreateNestedOneWithoutJOGOInput
    PREMIOS?: PREMIOSCreateNestedManyWithoutJOGOInput
  }

  export type JOGOUncheckedCreateWithoutNUMEROS_SORTEADOSInput = {
    id_jogo?: number
    data_hora: Date | string
    id_sala: number
    id_usuario_vencedor?: number | null
    preco_cartela: Decimal | DecimalJsLike | number | string
    CARTELA?: CARTELAUncheckedCreateNestedManyWithoutJOGOInput
    PREMIOS?: PREMIOSUncheckedCreateNestedManyWithoutJOGOInput
  }

  export type JOGOCreateOrConnectWithoutNUMEROS_SORTEADOSInput = {
    where: JOGOWhereUniqueInput
    create: XOR<JOGOCreateWithoutNUMEROS_SORTEADOSInput, JOGOUncheckedCreateWithoutNUMEROS_SORTEADOSInput>
  }

  export type JOGOUpsertWithoutNUMEROS_SORTEADOSInput = {
    update: XOR<JOGOUpdateWithoutNUMEROS_SORTEADOSInput, JOGOUncheckedUpdateWithoutNUMEROS_SORTEADOSInput>
    create: XOR<JOGOCreateWithoutNUMEROS_SORTEADOSInput, JOGOUncheckedCreateWithoutNUMEROS_SORTEADOSInput>
    where?: JOGOWhereInput
  }

  export type JOGOUpdateToOneWithWhereWithoutNUMEROS_SORTEADOSInput = {
    where?: JOGOWhereInput
    data: XOR<JOGOUpdateWithoutNUMEROS_SORTEADOSInput, JOGOUncheckedUpdateWithoutNUMEROS_SORTEADOSInput>
  }

  export type JOGOUpdateWithoutNUMEROS_SORTEADOSInput = {
    data_hora?: DateTimeFieldUpdateOperationsInput | Date | string
    preco_cartela?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    CARTELA?: CARTELAUpdateManyWithoutJOGONestedInput
    SALA?: SALAUpdateOneRequiredWithoutJOGONestedInput
    USUARIO?: USUARIOUpdateOneWithoutJOGONestedInput
    PREMIOS?: PREMIOSUpdateManyWithoutJOGONestedInput
  }

  export type JOGOUncheckedUpdateWithoutNUMEROS_SORTEADOSInput = {
    id_jogo?: IntFieldUpdateOperationsInput | number
    data_hora?: DateTimeFieldUpdateOperationsInput | Date | string
    id_sala?: IntFieldUpdateOperationsInput | number
    id_usuario_vencedor?: NullableIntFieldUpdateOperationsInput | number | null
    preco_cartela?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    CARTELA?: CARTELAUncheckedUpdateManyWithoutJOGONestedInput
    PREMIOS?: PREMIOSUncheckedUpdateManyWithoutJOGONestedInput
  }

  export type JOGOCreateWithoutPREMIOSInput = {
    data_hora: Date | string
    preco_cartela: Decimal | DecimalJsLike | number | string
    CARTELA?: CARTELACreateNestedManyWithoutJOGOInput
    SALA: SALACreateNestedOneWithoutJOGOInput
    USUARIO?: USUARIOCreateNestedOneWithoutJOGOInput
    NUMEROS_SORTEADOS?: NUMEROS_SORTEADOSCreateNestedManyWithoutJOGOInput
  }

  export type JOGOUncheckedCreateWithoutPREMIOSInput = {
    id_jogo?: number
    data_hora: Date | string
    id_sala: number
    id_usuario_vencedor?: number | null
    preco_cartela: Decimal | DecimalJsLike | number | string
    CARTELA?: CARTELAUncheckedCreateNestedManyWithoutJOGOInput
    NUMEROS_SORTEADOS?: NUMEROS_SORTEADOSUncheckedCreateNestedManyWithoutJOGOInput
  }

  export type JOGOCreateOrConnectWithoutPREMIOSInput = {
    where: JOGOWhereUniqueInput
    create: XOR<JOGOCreateWithoutPREMIOSInput, JOGOUncheckedCreateWithoutPREMIOSInput>
  }

  export type USUARIOCreateWithoutPREMIOSInput = {
    nome: string
    email: string
    senha: string
    creditos: Decimal | DecimalJsLike | number | string
    is_admin?: boolean
    CARTELA?: CARTELACreateNestedManyWithoutUSUARIOInput
    JOGO?: JOGOCreateNestedManyWithoutUSUARIOInput
  }

  export type USUARIOUncheckedCreateWithoutPREMIOSInput = {
    id_usuario?: number
    nome: string
    email: string
    senha: string
    creditos: Decimal | DecimalJsLike | number | string
    is_admin?: boolean
    CARTELA?: CARTELAUncheckedCreateNestedManyWithoutUSUARIOInput
    JOGO?: JOGOUncheckedCreateNestedManyWithoutUSUARIOInput
  }

  export type USUARIOCreateOrConnectWithoutPREMIOSInput = {
    where: USUARIOWhereUniqueInput
    create: XOR<USUARIOCreateWithoutPREMIOSInput, USUARIOUncheckedCreateWithoutPREMIOSInput>
  }

  export type JOGOUpsertWithoutPREMIOSInput = {
    update: XOR<JOGOUpdateWithoutPREMIOSInput, JOGOUncheckedUpdateWithoutPREMIOSInput>
    create: XOR<JOGOCreateWithoutPREMIOSInput, JOGOUncheckedCreateWithoutPREMIOSInput>
    where?: JOGOWhereInput
  }

  export type JOGOUpdateToOneWithWhereWithoutPREMIOSInput = {
    where?: JOGOWhereInput
    data: XOR<JOGOUpdateWithoutPREMIOSInput, JOGOUncheckedUpdateWithoutPREMIOSInput>
  }

  export type JOGOUpdateWithoutPREMIOSInput = {
    data_hora?: DateTimeFieldUpdateOperationsInput | Date | string
    preco_cartela?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    CARTELA?: CARTELAUpdateManyWithoutJOGONestedInput
    SALA?: SALAUpdateOneRequiredWithoutJOGONestedInput
    USUARIO?: USUARIOUpdateOneWithoutJOGONestedInput
    NUMEROS_SORTEADOS?: NUMEROS_SORTEADOSUpdateManyWithoutJOGONestedInput
  }

  export type JOGOUncheckedUpdateWithoutPREMIOSInput = {
    id_jogo?: IntFieldUpdateOperationsInput | number
    data_hora?: DateTimeFieldUpdateOperationsInput | Date | string
    id_sala?: IntFieldUpdateOperationsInput | number
    id_usuario_vencedor?: NullableIntFieldUpdateOperationsInput | number | null
    preco_cartela?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    CARTELA?: CARTELAUncheckedUpdateManyWithoutJOGONestedInput
    NUMEROS_SORTEADOS?: NUMEROS_SORTEADOSUncheckedUpdateManyWithoutJOGONestedInput
  }

  export type USUARIOUpsertWithoutPREMIOSInput = {
    update: XOR<USUARIOUpdateWithoutPREMIOSInput, USUARIOUncheckedUpdateWithoutPREMIOSInput>
    create: XOR<USUARIOCreateWithoutPREMIOSInput, USUARIOUncheckedCreateWithoutPREMIOSInput>
    where?: USUARIOWhereInput
  }

  export type USUARIOUpdateToOneWithWhereWithoutPREMIOSInput = {
    where?: USUARIOWhereInput
    data: XOR<USUARIOUpdateWithoutPREMIOSInput, USUARIOUncheckedUpdateWithoutPREMIOSInput>
  }

  export type USUARIOUpdateWithoutPREMIOSInput = {
    nome?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    creditos?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    is_admin?: BoolFieldUpdateOperationsInput | boolean
    CARTELA?: CARTELAUpdateManyWithoutUSUARIONestedInput
    JOGO?: JOGOUpdateManyWithoutUSUARIONestedInput
  }

  export type USUARIOUncheckedUpdateWithoutPREMIOSInput = {
    id_usuario?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    creditos?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    is_admin?: BoolFieldUpdateOperationsInput | boolean
    CARTELA?: CARTELAUncheckedUpdateManyWithoutUSUARIONestedInput
    JOGO?: JOGOUncheckedUpdateManyWithoutUSUARIONestedInput
  }

  export type JOGOCreateWithoutSALAInput = {
    data_hora: Date | string
    preco_cartela: Decimal | DecimalJsLike | number | string
    CARTELA?: CARTELACreateNestedManyWithoutJOGOInput
    USUARIO?: USUARIOCreateNestedOneWithoutJOGOInput
    NUMEROS_SORTEADOS?: NUMEROS_SORTEADOSCreateNestedManyWithoutJOGOInput
    PREMIOS?: PREMIOSCreateNestedManyWithoutJOGOInput
  }

  export type JOGOUncheckedCreateWithoutSALAInput = {
    id_jogo?: number
    data_hora: Date | string
    id_usuario_vencedor?: number | null
    preco_cartela: Decimal | DecimalJsLike | number | string
    CARTELA?: CARTELAUncheckedCreateNestedManyWithoutJOGOInput
    NUMEROS_SORTEADOS?: NUMEROS_SORTEADOSUncheckedCreateNestedManyWithoutJOGOInput
    PREMIOS?: PREMIOSUncheckedCreateNestedManyWithoutJOGOInput
  }

  export type JOGOCreateOrConnectWithoutSALAInput = {
    where: JOGOWhereUniqueInput
    create: XOR<JOGOCreateWithoutSALAInput, JOGOUncheckedCreateWithoutSALAInput>
  }

  export type JOGOCreateManySALAInputEnvelope = {
    data: JOGOCreateManySALAInput | JOGOCreateManySALAInput[]
    skipDuplicates?: boolean
  }

  export type JOGOUpsertWithWhereUniqueWithoutSALAInput = {
    where: JOGOWhereUniqueInput
    update: XOR<JOGOUpdateWithoutSALAInput, JOGOUncheckedUpdateWithoutSALAInput>
    create: XOR<JOGOCreateWithoutSALAInput, JOGOUncheckedCreateWithoutSALAInput>
  }

  export type JOGOUpdateWithWhereUniqueWithoutSALAInput = {
    where: JOGOWhereUniqueInput
    data: XOR<JOGOUpdateWithoutSALAInput, JOGOUncheckedUpdateWithoutSALAInput>
  }

  export type JOGOUpdateManyWithWhereWithoutSALAInput = {
    where: JOGOScalarWhereInput
    data: XOR<JOGOUpdateManyMutationInput, JOGOUncheckedUpdateManyWithoutSALAInput>
  }

  export type JOGOScalarWhereInput = {
    AND?: JOGOScalarWhereInput | JOGOScalarWhereInput[]
    OR?: JOGOScalarWhereInput[]
    NOT?: JOGOScalarWhereInput | JOGOScalarWhereInput[]
    id_jogo?: IntFilter<"JOGO"> | number
    data_hora?: DateTimeFilter<"JOGO"> | Date | string
    id_sala?: IntFilter<"JOGO"> | number
    id_usuario_vencedor?: IntNullableFilter<"JOGO"> | number | null
    preco_cartela?: DecimalFilter<"JOGO"> | Decimal | DecimalJsLike | number | string
  }

  export type CARTELACreateWithoutUSUARIOInput = {
    JOGO: JOGOCreateNestedOneWithoutCARTELAInput
    NUMEROS_CARTELA?: NUMEROS_CARTELACreateNestedManyWithoutCARTELAInput
  }

  export type CARTELAUncheckedCreateWithoutUSUARIOInput = {
    id_cartela?: number
    id_jogo: number
    NUMEROS_CARTELA?: NUMEROS_CARTELAUncheckedCreateNestedManyWithoutCARTELAInput
  }

  export type CARTELACreateOrConnectWithoutUSUARIOInput = {
    where: CARTELAWhereUniqueInput
    create: XOR<CARTELACreateWithoutUSUARIOInput, CARTELAUncheckedCreateWithoutUSUARIOInput>
  }

  export type CARTELACreateManyUSUARIOInputEnvelope = {
    data: CARTELACreateManyUSUARIOInput | CARTELACreateManyUSUARIOInput[]
    skipDuplicates?: boolean
  }

  export type JOGOCreateWithoutUSUARIOInput = {
    data_hora: Date | string
    preco_cartela: Decimal | DecimalJsLike | number | string
    CARTELA?: CARTELACreateNestedManyWithoutJOGOInput
    SALA: SALACreateNestedOneWithoutJOGOInput
    NUMEROS_SORTEADOS?: NUMEROS_SORTEADOSCreateNestedManyWithoutJOGOInput
    PREMIOS?: PREMIOSCreateNestedManyWithoutJOGOInput
  }

  export type JOGOUncheckedCreateWithoutUSUARIOInput = {
    id_jogo?: number
    data_hora: Date | string
    id_sala: number
    preco_cartela: Decimal | DecimalJsLike | number | string
    CARTELA?: CARTELAUncheckedCreateNestedManyWithoutJOGOInput
    NUMEROS_SORTEADOS?: NUMEROS_SORTEADOSUncheckedCreateNestedManyWithoutJOGOInput
    PREMIOS?: PREMIOSUncheckedCreateNestedManyWithoutJOGOInput
  }

  export type JOGOCreateOrConnectWithoutUSUARIOInput = {
    where: JOGOWhereUniqueInput
    create: XOR<JOGOCreateWithoutUSUARIOInput, JOGOUncheckedCreateWithoutUSUARIOInput>
  }

  export type JOGOCreateManyUSUARIOInputEnvelope = {
    data: JOGOCreateManyUSUARIOInput | JOGOCreateManyUSUARIOInput[]
    skipDuplicates?: boolean
  }

  export type PREMIOSCreateWithoutUSUARIOInput = {
    descricao: string
    valor: Decimal | DecimalJsLike | number | string
    JOGO: JOGOCreateNestedOneWithoutPREMIOSInput
  }

  export type PREMIOSUncheckedCreateWithoutUSUARIOInput = {
    id_premio?: number
    descricao: string
    valor: Decimal | DecimalJsLike | number | string
    id_jogo: number
  }

  export type PREMIOSCreateOrConnectWithoutUSUARIOInput = {
    where: PREMIOSWhereUniqueInput
    create: XOR<PREMIOSCreateWithoutUSUARIOInput, PREMIOSUncheckedCreateWithoutUSUARIOInput>
  }

  export type PREMIOSCreateManyUSUARIOInputEnvelope = {
    data: PREMIOSCreateManyUSUARIOInput | PREMIOSCreateManyUSUARIOInput[]
    skipDuplicates?: boolean
  }

  export type CARTELAUpsertWithWhereUniqueWithoutUSUARIOInput = {
    where: CARTELAWhereUniqueInput
    update: XOR<CARTELAUpdateWithoutUSUARIOInput, CARTELAUncheckedUpdateWithoutUSUARIOInput>
    create: XOR<CARTELACreateWithoutUSUARIOInput, CARTELAUncheckedCreateWithoutUSUARIOInput>
  }

  export type CARTELAUpdateWithWhereUniqueWithoutUSUARIOInput = {
    where: CARTELAWhereUniqueInput
    data: XOR<CARTELAUpdateWithoutUSUARIOInput, CARTELAUncheckedUpdateWithoutUSUARIOInput>
  }

  export type CARTELAUpdateManyWithWhereWithoutUSUARIOInput = {
    where: CARTELAScalarWhereInput
    data: XOR<CARTELAUpdateManyMutationInput, CARTELAUncheckedUpdateManyWithoutUSUARIOInput>
  }

  export type JOGOUpsertWithWhereUniqueWithoutUSUARIOInput = {
    where: JOGOWhereUniqueInput
    update: XOR<JOGOUpdateWithoutUSUARIOInput, JOGOUncheckedUpdateWithoutUSUARIOInput>
    create: XOR<JOGOCreateWithoutUSUARIOInput, JOGOUncheckedCreateWithoutUSUARIOInput>
  }

  export type JOGOUpdateWithWhereUniqueWithoutUSUARIOInput = {
    where: JOGOWhereUniqueInput
    data: XOR<JOGOUpdateWithoutUSUARIOInput, JOGOUncheckedUpdateWithoutUSUARIOInput>
  }

  export type JOGOUpdateManyWithWhereWithoutUSUARIOInput = {
    where: JOGOScalarWhereInput
    data: XOR<JOGOUpdateManyMutationInput, JOGOUncheckedUpdateManyWithoutUSUARIOInput>
  }

  export type PREMIOSUpsertWithWhereUniqueWithoutUSUARIOInput = {
    where: PREMIOSWhereUniqueInput
    update: XOR<PREMIOSUpdateWithoutUSUARIOInput, PREMIOSUncheckedUpdateWithoutUSUARIOInput>
    create: XOR<PREMIOSCreateWithoutUSUARIOInput, PREMIOSUncheckedCreateWithoutUSUARIOInput>
  }

  export type PREMIOSUpdateWithWhereUniqueWithoutUSUARIOInput = {
    where: PREMIOSWhereUniqueInput
    data: XOR<PREMIOSUpdateWithoutUSUARIOInput, PREMIOSUncheckedUpdateWithoutUSUARIOInput>
  }

  export type PREMIOSUpdateManyWithWhereWithoutUSUARIOInput = {
    where: PREMIOSScalarWhereInput
    data: XOR<PREMIOSUpdateManyMutationInput, PREMIOSUncheckedUpdateManyWithoutUSUARIOInput>
  }

  export type NUMEROS_CARTELACreateManyCARTELAInput = {
    id_numero_cartela?: number
    numero: number
  }

  export type NUMEROS_CARTELAUpdateWithoutCARTELAInput = {
    numero?: IntFieldUpdateOperationsInput | number
  }

  export type NUMEROS_CARTELAUncheckedUpdateWithoutCARTELAInput = {
    id_numero_cartela?: IntFieldUpdateOperationsInput | number
    numero?: IntFieldUpdateOperationsInput | number
  }

  export type NUMEROS_CARTELAUncheckedUpdateManyWithoutCARTELAInput = {
    id_numero_cartela?: IntFieldUpdateOperationsInput | number
    numero?: IntFieldUpdateOperationsInput | number
  }

  export type CARTELACreateManyJOGOInput = {
    id_cartela?: number
    id_usuario: number
  }

  export type NUMEROS_SORTEADOSCreateManyJOGOInput = {
    id_numero_sorteado?: number
    numero: number
    ordem_sorteio: number
  }

  export type PREMIOSCreateManyJOGOInput = {
    id_premio?: number
    descricao: string
    valor: Decimal | DecimalJsLike | number | string
    id_usuario?: number | null
  }

  export type CARTELAUpdateWithoutJOGOInput = {
    USUARIO?: USUARIOUpdateOneRequiredWithoutCARTELANestedInput
    NUMEROS_CARTELA?: NUMEROS_CARTELAUpdateManyWithoutCARTELANestedInput
  }

  export type CARTELAUncheckedUpdateWithoutJOGOInput = {
    id_cartela?: IntFieldUpdateOperationsInput | number
    id_usuario?: IntFieldUpdateOperationsInput | number
    NUMEROS_CARTELA?: NUMEROS_CARTELAUncheckedUpdateManyWithoutCARTELANestedInput
  }

  export type CARTELAUncheckedUpdateManyWithoutJOGOInput = {
    id_cartela?: IntFieldUpdateOperationsInput | number
    id_usuario?: IntFieldUpdateOperationsInput | number
  }

  export type NUMEROS_SORTEADOSUpdateWithoutJOGOInput = {
    numero?: IntFieldUpdateOperationsInput | number
    ordem_sorteio?: IntFieldUpdateOperationsInput | number
  }

  export type NUMEROS_SORTEADOSUncheckedUpdateWithoutJOGOInput = {
    id_numero_sorteado?: IntFieldUpdateOperationsInput | number
    numero?: IntFieldUpdateOperationsInput | number
    ordem_sorteio?: IntFieldUpdateOperationsInput | number
  }

  export type NUMEROS_SORTEADOSUncheckedUpdateManyWithoutJOGOInput = {
    id_numero_sorteado?: IntFieldUpdateOperationsInput | number
    numero?: IntFieldUpdateOperationsInput | number
    ordem_sorteio?: IntFieldUpdateOperationsInput | number
  }

  export type PREMIOSUpdateWithoutJOGOInput = {
    descricao?: StringFieldUpdateOperationsInput | string
    valor?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    USUARIO?: USUARIOUpdateOneWithoutPREMIOSNestedInput
  }

  export type PREMIOSUncheckedUpdateWithoutJOGOInput = {
    id_premio?: IntFieldUpdateOperationsInput | number
    descricao?: StringFieldUpdateOperationsInput | string
    valor?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    id_usuario?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PREMIOSUncheckedUpdateManyWithoutJOGOInput = {
    id_premio?: IntFieldUpdateOperationsInput | number
    descricao?: StringFieldUpdateOperationsInput | string
    valor?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    id_usuario?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type JOGOCreateManySALAInput = {
    id_jogo?: number
    data_hora: Date | string
    id_usuario_vencedor?: number | null
    preco_cartela: Decimal | DecimalJsLike | number | string
  }

  export type JOGOUpdateWithoutSALAInput = {
    data_hora?: DateTimeFieldUpdateOperationsInput | Date | string
    preco_cartela?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    CARTELA?: CARTELAUpdateManyWithoutJOGONestedInput
    USUARIO?: USUARIOUpdateOneWithoutJOGONestedInput
    NUMEROS_SORTEADOS?: NUMEROS_SORTEADOSUpdateManyWithoutJOGONestedInput
    PREMIOS?: PREMIOSUpdateManyWithoutJOGONestedInput
  }

  export type JOGOUncheckedUpdateWithoutSALAInput = {
    id_jogo?: IntFieldUpdateOperationsInput | number
    data_hora?: DateTimeFieldUpdateOperationsInput | Date | string
    id_usuario_vencedor?: NullableIntFieldUpdateOperationsInput | number | null
    preco_cartela?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    CARTELA?: CARTELAUncheckedUpdateManyWithoutJOGONestedInput
    NUMEROS_SORTEADOS?: NUMEROS_SORTEADOSUncheckedUpdateManyWithoutJOGONestedInput
    PREMIOS?: PREMIOSUncheckedUpdateManyWithoutJOGONestedInput
  }

  export type JOGOUncheckedUpdateManyWithoutSALAInput = {
    id_jogo?: IntFieldUpdateOperationsInput | number
    data_hora?: DateTimeFieldUpdateOperationsInput | Date | string
    id_usuario_vencedor?: NullableIntFieldUpdateOperationsInput | number | null
    preco_cartela?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type CARTELACreateManyUSUARIOInput = {
    id_cartela?: number
    id_jogo: number
  }

  export type JOGOCreateManyUSUARIOInput = {
    id_jogo?: number
    data_hora: Date | string
    id_sala: number
    preco_cartela: Decimal | DecimalJsLike | number | string
  }

  export type PREMIOSCreateManyUSUARIOInput = {
    id_premio?: number
    descricao: string
    valor: Decimal | DecimalJsLike | number | string
    id_jogo: number
  }

  export type CARTELAUpdateWithoutUSUARIOInput = {
    JOGO?: JOGOUpdateOneRequiredWithoutCARTELANestedInput
    NUMEROS_CARTELA?: NUMEROS_CARTELAUpdateManyWithoutCARTELANestedInput
  }

  export type CARTELAUncheckedUpdateWithoutUSUARIOInput = {
    id_cartela?: IntFieldUpdateOperationsInput | number
    id_jogo?: IntFieldUpdateOperationsInput | number
    NUMEROS_CARTELA?: NUMEROS_CARTELAUncheckedUpdateManyWithoutCARTELANestedInput
  }

  export type CARTELAUncheckedUpdateManyWithoutUSUARIOInput = {
    id_cartela?: IntFieldUpdateOperationsInput | number
    id_jogo?: IntFieldUpdateOperationsInput | number
  }

  export type JOGOUpdateWithoutUSUARIOInput = {
    data_hora?: DateTimeFieldUpdateOperationsInput | Date | string
    preco_cartela?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    CARTELA?: CARTELAUpdateManyWithoutJOGONestedInput
    SALA?: SALAUpdateOneRequiredWithoutJOGONestedInput
    NUMEROS_SORTEADOS?: NUMEROS_SORTEADOSUpdateManyWithoutJOGONestedInput
    PREMIOS?: PREMIOSUpdateManyWithoutJOGONestedInput
  }

  export type JOGOUncheckedUpdateWithoutUSUARIOInput = {
    id_jogo?: IntFieldUpdateOperationsInput | number
    data_hora?: DateTimeFieldUpdateOperationsInput | Date | string
    id_sala?: IntFieldUpdateOperationsInput | number
    preco_cartela?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    CARTELA?: CARTELAUncheckedUpdateManyWithoutJOGONestedInput
    NUMEROS_SORTEADOS?: NUMEROS_SORTEADOSUncheckedUpdateManyWithoutJOGONestedInput
    PREMIOS?: PREMIOSUncheckedUpdateManyWithoutJOGONestedInput
  }

  export type JOGOUncheckedUpdateManyWithoutUSUARIOInput = {
    id_jogo?: IntFieldUpdateOperationsInput | number
    data_hora?: DateTimeFieldUpdateOperationsInput | Date | string
    id_sala?: IntFieldUpdateOperationsInput | number
    preco_cartela?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type PREMIOSUpdateWithoutUSUARIOInput = {
    descricao?: StringFieldUpdateOperationsInput | string
    valor?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    JOGO?: JOGOUpdateOneRequiredWithoutPREMIOSNestedInput
  }

  export type PREMIOSUncheckedUpdateWithoutUSUARIOInput = {
    id_premio?: IntFieldUpdateOperationsInput | number
    descricao?: StringFieldUpdateOperationsInput | string
    valor?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    id_jogo?: IntFieldUpdateOperationsInput | number
  }

  export type PREMIOSUncheckedUpdateManyWithoutUSUARIOInput = {
    id_premio?: IntFieldUpdateOperationsInput | number
    descricao?: StringFieldUpdateOperationsInput | string
    valor?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    id_jogo?: IntFieldUpdateOperationsInput | number
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}